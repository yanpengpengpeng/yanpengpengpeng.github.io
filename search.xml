<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原生JS实现复制功能]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[适用React、Vue、Angular框架 实现: 利用JS原生提供的API，点击时模拟电脑键Ctrl+c的功能; API: createRange,execCommand等等; 下面上代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React, &#123; Component &#125; from 'react'; import &#123; List, Button, message &#125; from 'antd';const Item = List.Itemclass textList extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; this.list=[ &#123;title:'1',value:'red'&#125;, &#123;title:'2',value:'orange'&#125;, &#123;title:'3',value:'yellow'&#125;, &#123;title:'4',value:'pick'&#125;, ]; &#125;; copyContent(val)&#123; // 清除组件渲染前粘贴板的内容 window.getSelection().removeAllRanges(); // 生成复制区域的dom元素 const activeCodeSpan = document.getElementById(`$&#123;val.title&#125;`); // 创建一个区域 const range = document.createRange(); // 区域选中需要复制内容的dom元素 range.selectNodeContents(activeCodeSpan); // window全局下，选中这个range window.getSelection().addRange(range); // 模拟电脑Ctrl+c的命令 const tag = document.execCommand("copy"); if(tag)&#123; message.success('内容已复制成功',1); // 复制成功，清除粘贴板中的内容 window.getSelection().removeAllRanges(); &#125;; &#125;; render()&#123; return( &lt;List itemLayout='horizontal' dataSource=&#123;this.list&#125; renderItem=&#123;item =&gt; ( &lt;Item id=&#123;item.title&#125; actions=&#123;[&lt;Button onClick=&#123;() =&gt; &#123;this.copyContent(item)&#125;&#125;&gt;复制&lt;/Button&gt;]&#125; &gt; &lt;Item.Meta title=&#123;item.title&#125; description=&#123;item.value&#125; /&gt; &lt;/Item&gt; )&#125; &gt; &lt;/List&gt; ) &#125; &#125;export default textList;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Hooks]]></title>
    <url>%2F2019%2F04%2F21%2FReact-Hooks%2F</url>
    <content type="text"><![CDATA[HooksReact16.7alpha新版本中新增useState useEffect等API； 函数式编程将业务逻辑从展示组件中剥离出来，结构更加清晰；通过hooks将UI组件和数据更加清晰得分离开；UI组件使用纯函数进行表达；useState useEffect来代替react常规组件中的生命周期钩子函数； React常规组件实现业务逻辑123456789101112131415161718192021222324import React,&#123;Component&#125; from 'react';class Container extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; count:0 &#125; this.handleChangeCount = this.handleChangeCount.bind(this) &#125; handleChangeCount()&#123; this.setState(&#123; count:this.state.count++ &#125;) &#125; render()&#123; return( &lt;div&gt; &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt; &lt;button onClick = &#123;this.handleChangeCount&#125;&gt;点击增加&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; React-Hooks实现数字累加逻辑组件 对useState使用解构，类似constructor构造器初始化数据； useEffect当数据改变时的钩子函数； useEffect的第二个参数是一个数组，钩子函数会根据数组的数据变化而执行； setCount相当于setState函数，对数据进行更新123456789101112131415161718import react,&#123;Component,useState,useEffect&#125; from 'react';function CountChange(props)&#123; // 类似constructor构造器初始化数据 const [count,setCount] = useState(0) // side effect函数 当数据改变时的钩子函数 // componentDidMount、componentDidUpdate的结合体 useEffect(()=&gt;&#123; documents.title = `you clicked $&#123;count&#125; times` &#125;,[count]) return( &lt;div&gt; &lt;p&gt;you clicked &#123;count&#125; times&lt;/p&gt; // setCount相当于setState函数，对数据进行更新 &lt;button click =&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;点击增加&lt;/button&gt; &lt;/div&gt; ) &#125; 通过Hooks自定义钩子，抽离可复用的逻辑代码 应用场景 当两个组件需要公用一个逻辑对自己组件内部的状态进行判断 抽离公共逻辑，进行自定义钩子的封装 使用useEffect函数需return一个函数，类似removeEventListener移除事件；12345678910111213141516171819import react,&#123; useState, useEffect&#125; from 'react';// 抽离custom logicfunction useFriendStatus(friendID)&#123; const [isOline, setIsOline] = useState(null) function handleStatusChange(status)&#123; setIsOline(status.isOline) &#125; useEffect(()=&gt;&#123; chatAPI.subscribetoFriendStatus(friendID,handleStatusChange) return chatAPI.unsubscribefromFriendStatus(friendID,handleStatusChange) &#125;) return &#123; isOline &#125;&#125;// 在其他组件使用这个公用hooks]]></content>
      <categories>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiber版本生命周期浅析]]></title>
    <url>%2F2019%2F03%2F27%2Freact_lifecycle%2F</url>
    <content type="text"><![CDATA[React 16.4版本生命周期变化 16版本之前的componentWillMount、componentWillReceiveProps、componentWillUpdate将被移除;新增 getDerivedStateFromProps、getSnapshotBeforeUpdate ;react框架将采用异步渲染机制，上述三个周期函数将会变的不安全，产生bug;另新增 componentDidCatch 周期函数，处理render函数渲染错误的捕捉; componentWillMount周期函数 若将异步请求数据的业务放在这个函数内，也会导致首屏白屏,怎么滴也赶不上render函数渲染 若是服务端渲染，此函数将会被执行两次 服务端渲染也不能保证componentWillUnmount周期函数执行，若在componentWillMount订阅事件，则会造成内存泄漏 尽量将数据请求放在componentDidMount函数内执行，此时dom已挂载完毕，不会造成影响，比较安全; componentWillReceiveProps 和 getDerivedStateFromProps 的比较应用场景: 当组件内的state和props紧密联系时 componentWillReceiveProps(nextProps) 更新state 执行回调函数 getDerivedStateFromProps(nextProps, prevState) 只专注于props和state的比较，来更新state 比较新旧的代码1234567891011121314151617181920212223242526// beforecomponentWillReceiveProps(nextProps) &#123; if (nextProps.isLogin !== this.props.isLogin) &#123; this.setState(&#123; isLogin: nextProps.isLogin, &#125;); &#125; if (nextProps.isLogin) &#123; this.handleClose(); &#125;&#125;// afterstatic getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.isLogin !== prevState.isLogin) &#123; return &#123; isLogin: nextProps.isLogin, &#125;; &#125; return null;&#125;componentDidUpdate(prevProps, prevState) &#123; if (!prevState.isLogin &amp;&amp; this.props.isLogin) &#123; this.handleClose(); &#125;&#125; 在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。 componentWillUpdate 和 getSnapshotBeforeUpdate componentWillUpdate 都有可能在一次更新中被调用多次，显然是不可取的，将回调函数放在componentDidUpdate componentWillUpdate getSnapshotBeforeUpdate(prevProps, prevState) 返回值作为第三个参数传入componentDidUpdate官方例子123456789101112131415161718192021222324252627282930313233343536class ScrollingList extends React.Component &#123; listRef = null; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // Are we adding new items to the list? // Capture the scroll position so we can adjust scroll later. if (prevProps.list.length &lt; this.props.list.length) &#123; return ( this.listRef.scrollHeight - this.listRef.scrollTop ); &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // If we have a snapshot value, we've just added new items. // Adjust scroll so these new items don't push the old ones out of view. // (snapshot here is the value returned from getSnapshotBeforeUpdate) if (snapshot !== null) &#123; this.listRef.scrollTop = this.listRef.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.setListRef&#125;&gt; &#123;/* ...contents... */&#125; &lt;/div&gt; ); &#125; setListRef = ref =&gt; &#123; this.listRef = ref; &#125;;&#125;]]></content>
      <categories>
        <category>lifecycle</category>
      </categories>
      <tags>
        <tag>lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack4]]></title>
    <url>%2F2019%2F03%2F12%2Fwebpack4%2F</url>
    <content type="text"><![CDATA[webpack4新特性 新增webpack-cli脚手架 集成webpack命令 npx 命令 零配置，开箱即用默认入口文件为src目录下的index.js,出口为dist目录下的main.js 新增mode模式切换，默认为生产环境 需手动设置为开发模式 mode：development 基本配置1234567891011121314151617181920212223242526let path = require('path')module.exports = &#123; optimization:&#123; // 优化项 minimizer:[ new OptimizeCssAssetsWebpackPlugin() // 压缩css文件 new UglifyJsPlugin(&#123; cache:true, // 是否缓存 parallel:true, // 是否并发请求 sourceMap:true // es6高阶语法产生映射 &#125;) // 压缩js文件 ] &#125; devServer:&#123; // 开发服务器的配置 port:3000, progress：true, contentBase:'./build', open:true, compress:true &#125; mode:'development', // 模式 production development entry:'./src/index.js',//入口 output:&#123; filename:'bundle.[hash:8]js',//打包后的文件名 增加hsah之后，防止覆盖 path:path.resolve(__dirname,'build) // 路径必须是一个绝对路径 &#125;&#125; 常用插件配置 HtmlWebpackPlugin 在内存中生成html文件，并将js文件自动插入 MiniCssExtractPlgin 抽离css文件，生成单独的文件，插入到link标签内 OptimizeCssAssetsWebpackPlugin 压缩css文件 UglifyJsPlugin 压缩JS文件1234567891011121314plugins:[ // 数组 放着所有的webpack的插件 new HtmlWebpackPlugin(&#123; template:'./src/index.html', //指定模板html文件 filename:'index.html', minify:&#123; removeAttributeQuotes:true, // 去掉html中的双引号 collapseWhitespace:true,//压缩html代码为一行 &#125;, hash:true &#125;), new MiniCssExtractPlgin(&#123; &#125;)] 常用模块配置 解析样式文件 css-loader style-loader less-loader file-loader 处理图片 postcss-loader 给样式增加前缀 需要配置postcss.config.js文件 文件导出autofix1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950module:&#123; route:[ // 处理css文件 // css-loader 解析css文件@import语法 // style-loader 把css文件插入到head标签中 // loader的顺序是从右到左 // loader写成对象模式，可以设置更多的参数 &#123;test:/\.css$/,use:[ &#123; loader:'style-loader'. options:&#123; insertAt:'top' &#125; &#125;, 'css-loader' ] &#125;, // 处理less文件 &#123;test:/\.css$/,use:[ MiniCssExtractPlgin.loader, // 抽离less文件 'css-loader', // 解析@import语法 路径 'less-loader',// 解析less文件 'postcss-loader' // 给类似transform样式增加webkit前缀 ] &#125;, // 处理js文件 &#123;test:/\.js$/, use:[ loader:'babel-loader', options:&#123; presets:[ '@babel/preset-env' ], plugins:[ ["@babel/plugin-proposal-decorators",&#123;"legacy":true&#125;] ] &#125;, exclude:/node_modules/ //排除node包中的js文件 ]&#125;, // 处理图片 &#123;test:/\.(png|jpg|gif)/, //use:'file-loader' // 处理后返回一个hash戳前缀名字的图片 use:'url-loader' // 通常用这个loader处理图片，转成base &#125;, // 处理html文件的图片 &#123;test:/\.html$/, use:'html-withimg-loader' &#125; ]&#125; 对于框架 多个文件多次引用raect react-dom 如何优化 新建一个动态链接库 抽离公共第三方包 webpack.config.react.js 并在dist目录下script标签引用这个动态链接库 在webpack.config.js住配置文件中使用12345678910111213141516171819let path = require(path);let webpack = require(webpack)module.exports = &#123; mode:&apos;development&apos;, entry:&#123; react:[&apos;react&apos;,&apos;react-dom&apos;] &#125;, output:&#123; filename:&apos;_dll_[name].js&apos;,//产生的文件名 path:path.reslove(__dirname,&apos;dist), library:&apos;_dll_[name]&apos; &#125;, plugins:[ new webpack.DllPlugin(&#123; name:&apos;_dll_[name]&apos;, path:path.resolve(__dirname,&apos;dist&apos;,&apos;manifest.json&apos;) &#125;) ]&#125; 12345plugins:[ new webpack.DllReferencePlugin(&#123; manifest:path.resolve(__dirname,&apos;dist&apos;,&apos;manifest.json&apos;) &#125;)] 代码分割 形成公用模块12345678910111213141516171819module.exports = &#123; optimiztion:&#123; // 优化项目 splitChunks:&#123; // 分割代码块 cacheGroups:&#123; // 缓存组 common:&#123; // 公共模块 chunks:&apos;initial&apos;, minSize:0, minChunks:2 &#125;, vendor:&#123; test:/node_modules/, //把第三方公用的库抽离 chunks:&apos;initial&apos;, minSzie:0, minChunks:2 &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express]]></title>
    <url>%2F2019%2F01%2F12%2Fexpress4%2F</url>
    <content type="text"><![CDATA[创建Express项目安装Express脚手架 npm install -g express-generator npm install -g express创建一个Express工程化项目 express -e myApp 使用ejs模板,创建一个myApp目录 cd myApp &amp;&amp; npm install 安装项目依赖的模块启动项目 npm start Express API-]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Express XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxt.js]]></title>
    <url>%2F2018%2F12%2F22%2FNuxt%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[项目重构 使用微信第三方账号登录 使用nuxt.js框架，实现SSR 使用vw + vh 适配方案 Nuxt 基于Vue.js的应用框架]]></content>
      <categories>
        <category>项目重构</category>
      </categories>
      <tags>
        <tag>nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在荒岛上迎接黎明 - 王小波]]></title>
    <url>%2F2018%2F11%2F11%2F%E7%BE%8E%E6%96%87%2F</url>
    <content type="text"><![CDATA[我在荒岛上迎接黎明 我在荒岛上迎接黎明。太阳初升时，忽然有十万支金喇叭齐鸣。阳光穿过透明的空气，在暗蓝色的天空飞过。在黑暗尚未褪去的海面上燃烧着十万支蜡烛。我听见天地之间钟声响了，然后十万支金喇叭又一次齐鸣。我忽然泪如雨下，但是我心底在欢歌。有一柄有弹性的长剑从我胸中穿过，带来了剧痛似的巨大快感。这是我一生最美好的时刻，我站在那一个门坎上，从此我将和永恒连结在一起……因为确确实实地知道我已经胜利，所以那些燃烧的字句就在我眼前出现，在我耳中轰鸣。这是一首胜利之歌，音韵铿锵，有如一支乐曲。我摸着水湿过的衣袋，找到了人家送我划玻璃的那片硬质合金。于是我用有力的笔迹把我的诗刻在石壁上，这是我的胜利纪念碑。在这孤零零的石岛上到处是风化石，只有这一片坚硬而光滑的石壁。我用我的诗把它刻满，又把字迹加深，为了使它在这人迹罕至的地方永久存在。 在我小的时候，常有一种冰凉的恐怖使我从睡梦中惊醒，我久久地凝视着黑夜。我不明白我为什么会死。到我死时，一切感觉都会停止，我会消失在一片混沌之中。我害怕毫无感觉，宁愿有一种感觉长久存在。哪怕它是疼。 长大了一点的时候，我开始苦苦思索。我知道宇宙和永恒是无限的，而我自己和一切人一样都是有限的。我非常非常不喜欢这个对比，老想把它否定掉。于是我开始思考是否有一种比人和人类更伟大的意义。想明白了从人的角度看来这种意义是不存在的以后，我面前就出现了一片寂寞的大海。人们所做的一切不过是些死前的游戏…… 在冥想之中长大了以后，我开始喜欢诗。我读过很多诗，其中有一些是真正的好诗。好诗描述过的事情各不相同，韵律也变化无常，但是都有一点相同的东西。它有一种水晶般的光辉，好象是来自星星……真希望能永远读下去，打破这个寂寞的大海。我希望自己能写这样的诗。我希望自己也是一颗星星。如果我会发光，就不必害怕黑暗。如果我自己是那么美好，那么一切恐惧就可以烟消云散。于是我开始存下了一点希望——如果我能做到，那么我就战胜了寂寞的命运。 但是我好久好久没有动笔写，我不敢拿那么重大的希望去冒险。如果我写出来糟不可言，那么一切都完了。 我十七岁到南方去插队。旱季里，那儿的天空是蓝湛湛的，站在小竹楼里往四下看，四处的竹林翠绿而又苗条。天上的云彩又洁白又丰腴，缓缓地浮过。我觉得应该试一试。 开始时候象初恋一样神秘，我想避开别人来试试自己。午夜时分，我从床上溜下来，听着别人的鼻息，悄悄地走到窗前去，在皎洁的月光下坐着想。似乎有一些感受、一些模糊不清的字句，不知写下来是什么样的。在月光下，我用自来水笔在一面镜子上写。写出的字句幼稚得可怕。我涂了又写，写了又涂，直到把镜子涂成暗蓝色，把手指和手掌全涂成蓝色才罢手。回到床上，我哭了。这好象是一个更可怕的噩梦。 后来我在痛苦中写下去，写了很久很久，我的本子上出现很多歪诗、臭诗，这很能刺激我写下去。到写满了三十个笔记本时，我得了一场大病，出院以后瘦得象一只瘦猫。正午时分，我蹲下又站起来，四周的一切就变成绿色的。 我病退回北京，住在街道上借来的一间小屋里。在北京能借到很多书，我读了很多文艺理论，从亚里士多德到苏联的比西莫夫，试着从理性分析中找到一条通向目标的道路，结果一无所成。 那时候我穷得发疯，老盼着在地上拣到钱。我是姑姑养大的，可是她早几年死了。工作迟迟没有着落，又不好意思找同学借钱。我转起各种念头，但是我绝对不能偷。我做不出来。想当临时工，可是户口手续拖着办不完。剩下的只要捡破烂一条路了。 在天黑以后，我拿了一条破麻袋走向垃圾站。我站在垃圾堆上却弯不下腰来。这也许要从小受到熏陶，或者饿得更厉害些。我拎着空麻袋走开时却碰上一位姑娘从这儿走过。我和她只有一面之识，可她却再三盘问我。我编不出谎来，只好照实招了。 她几乎哭了出来，非要到我住的地方看看不可。在那儿，我把我的事情都告诉她了。那一天我很不痛快，就告诉她我准备把一切都放弃。她把我写过的东西看了一遍之后，指出有三首无可挑剔的好诗。她说事情也许不象我想的那么糟糕。但是我无论如何也想不起来那三首诗是怎么写出来的了。我还不是一个源泉，一个发光体，那么什么也安慰不了我。 后来她常到我这儿来。我把我写的都给她看，因为她独具慧眼，很能分出好坏来。她聪明又漂亮。后来我们把这些都放下，开始谈起恋爱来，晚上在路灯的暗影里接吻。过了三个月她要回插队的老家去，我也跟她去了。 在大海边上，有一个小村镇。这儿是公社的所在地，她在公社当广播员，把我安排在公社中学代课。 她有三间大瓦房，盖在村外的小山坡上，背朝着大海，四面不靠人家，连院墙都没有，从陆上吹来的风毫无阻碍地吹着门窗。她很需要有人做伴，于是我也住进那座房子，对外说我是她的表哥，盖这座房子用了我家的钱。人家根本不信，不过也不来管我们的闲事。我们亲密无间，但是没感到有什么必要去登记结婚。我住在东边屋里，晚上常常睡不着觉在门口坐着，她也常来陪我。我们有很多时候来谈论，有很多次谈到我。 看来写诗对我是一个不堪的重负，可是这已经是一件不可更改的事情了。我必须在这条路上走到底。我必须追求这种能力，必须永远努力下去。我的敌手就是我自己，我要他美好到使我满意的程度。她希望我能斗争到底。她喜欢的就是人能做到不可能做到的事情，她的一切希望就系之与于此。如果没有不可能的事情，那么一切都好办了。 我不断地试下去，写过无数的坏诗。偶尔也写过几个美好的句子，但是没有真正使她满意的一篇。我好象老在贫乏的圈子里转来转去，爬不出去。我找过各种各样的客观与主观原因，可是一点帮助也没有。她说我应该从原地朝前跨一步，可是我动弹不得。 我就这么过了好几年。有时挎着她的手到海边去散步时我想：“算了吧！我也算是幸福的了。她是多么好的伴侣。也许满足了就会幸福。”可是我安静不下来。我的脑子总是在想那个渺茫的目标。我常常看到那个寂寞的大海。如果我停下来，那么就是寂寞，不如试下去。 昨天早上，校长让我带十几个学生去赶大潮。我们分两批到大海中间的沙滩上去挖牡蛎，准备拿回去卖给供销社，给学校增加一点收入。下午第一批学生上船以后，忽然起了一阵大风，风是从陆上吹来的。这时潮水已经涨到平了沙滩，浪花逐渐大了起来，把沙洲上的沙子全掀了起来。如果浪把我们打到海里，学生们会淹死，我也可能淹死，淹不死也要进监狱。我让学生们拉住我的裤腰带，推着我与大海对抗。我身高一米九零，体重一百八十斤，如果浪卷不走我，学生们也会安全。 小船来接我们时，浪高得几乎要把我浮起来，一浮起来我们就完了。小船不敢靠近，批在沙滩上搁浅，就绕到下风处，我把学生一个一个从浪峰推出去，让他们漂到船上去。最后一个学生会一点水，我和他一起浮起来时，他一个狗刨动作正刨在我下巴上，打得我晕了几秒钟，醒过来时几乎灌饱了。我再浮上水面，小船已经离得很远。我喊了一声，他们没有听见，我又随浪沉下去。再浮到浪顶时，小船已经摇走，他们一定以为我淹死了。 我在海里挣扎了很久，陆地在天边消失了。我一个劲地往海底沉，因为我比重太大，很不容易浮起来。大海要淹死我。可是我碰上了一条没浆的小船在海上乱漂。我爬上船去，随它漂去。我晕得一塌糊涂，吐了个天翻地覆。天黑以后，风停了。我看见这座大海之中的一个小孤岛，就游了上来。 我在荒岛上迎接黎明，我听到了金喇叭的声音。在这个荒岛上，我写出了一生中第一首从源泉中涌出来的诗，我把它刻在了石头上。 在我的四周都是海，闪着金光，然后闪着银光，天空从浅红变做天蓝。海面上看不见一条船。在这小岛顶上有一座玩具一样的龙王庙。也许人们不会来救我，我还要回到海里，试着自己游回岸上去但是我并不害怕。我不觉得饿，还可以支持很久。我既可以等待，也可以游泳。现在我愿意等待。于是我叉手于胸站在小岛顶上。我感到自豪，因为我取得了第一个胜利，我毫不怀疑胜利是会接踵而至的。我能够战胜命运，把自己随心所欲地改变，所以我是英雄。我做到了第一件做不到的事情，我也可以接着做下去。我喜欢我的诗，因为我知道它是真正美好的，它身上有无可争辩的光辉。我也喜欢我自己造出的我自己，我对他满意了。 有一只小船在天边出现，一个白色的小点，然后又象一只白天鹅。我站在山顶上，把衬衫脱下来挥舞。是她，独自划着一条白色的救生艇，是从海军炮校的游泳场搞来的。她在船上挥着手。我跑到岸边去接她。 她哭着拥抱我，说在海上找了我一夜。人们都相信我已经淹死了，但是她不相信我会死。我把她引到那块石头前，让她看我写的诗。她默默地看了很久，然后向我要那片硬质合金，要我把我的名字刻上去。可是我不让她刻。我不需要刻上我的名字。名字对我无关紧要。我不希望人们知道我的名字，因为我的胜利是属于我的。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>王小波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript基本语法]]></title>
    <url>%2F2018%2F07%2F04%2FTS%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用TypeScript的目的是什么?TypeScript最大的目的是让程序员更具创造性，提高生产力，它将极大增强JavaScript编写应用的开发和调试环节，让JavaScript能够方便与编写大型应用和进行多人协作; TypeScript 和 JavaScript 的对比 TypeScript 是一个应用程序级的 JavaScript 开发语言。（这也表示 TypeScript 比较牛X,可以开发大型应用，或者说更适合大型应用。） TypeScript 是 JavaScritpt 的超集，可以编译成纯 JavaScript 。比较像 Less 和 Sass，我们可以用更好的代码编写方式来进行编写，最后还是友好生成原生的 JavaScript 语言。 TypeScript 跨浏览器、跨操作系统、跨主机、且开源。由于最后它编译成了 JavaScript 所以只要能运行 JS的地方，都可以运行我们写的程序，设置在 node.js 里。 TypeScript 始于JavaScript , 终于JavaScript。遵循 JavaScript 的语法和语义，所以对于我们前端从业者来说，学习起来的的心用手，并没有太大的难度。 TypeScript可以重用JavaScript代码，调用流行的 JavaScript库。 TypeScript提供了类、模块和接口，更易于构建组件和维护。 TS语法初始化一个项目 1.初始化项目:进入你的编程文件夹后，可以使用npm init -y来初始化项目，生成package.json文件。 2.创建tsconfig.json文件:在终端中输入tsc –init：它是一个TypeScript项目的配置文件，可以通过读取它来设置TypeScript编译器的编译参数。 3.安装@types/node模块,使用npm install @types/node –dev-save进行安装。这个主要是解决模块的声明文件问题。 4.编写HelloWorld.ts文件，然后进行保存，代码如下。12var a:string = "HelloWorld"console.log(a) 5.在Vscode的任务菜单下，打开Terminal下的Run Build Task，然后选择tsc：build-tsconfig.json，这时候就会生成一个helloWorld.js文件123"use strict";var a = 'helloworld';console.log(a); 6.在终端中输入node helloWorld.js就可以看到结果了。 TS中函数的定义方式及传参形式 函数的定义 函数声明: function add(n1:number,n2:number):number{return n1 + n2} 函数表达式：const add = function(n1:number,n2:number){return n1 + n2} 箭头函数: const add = (n1:number,n2:number):number =&gt; n1 + n2 使用接口来定义函数 : 在这种函数实现接口的情形下，我们称这种定义为callable12345interface Complex &#123; (bar?:number,...others:boolean[]):number;&#125;let foo:Complex这种定义方式在可复用的函数声明中非常有用。 123456interface CallMeWithNewToGetString&#123; new():string&#125;let foo:CallMeWithNewToGetStringnew foo();这个在构造函数的声明时非常有用。 传参形式:基本传参 可选传参 默认传参 剩余传参 函数的重载 数组 let arr1:number[] //声明一个数值类型的数组 let arr2:Array&lt;string&gt; //声明一个字符串类型的数组 let arr3:boolean[] // 声明一个布尔值的数组 当类型和数量不确定时，使用元数组 let arr4:[number,string] let arr5:any[] 都未知的情况下，第一个数组 接口类型 普通接口 提高代码复用率，使用此接口类型 123456789interface Name &#123; first:string second:string&#125;let personName:Name = &#123; first:'张'&#125;// Property 'second' is missing in type '&#123; first: string; &#125;' but required in type 'Name' 内联接口 123var personName:&#123; first: string, second: string &#125; = &#123; first: '张三'&#125; // Property 'second' is missing in type '&#123; first: string; &#125;' but required in type 'Name' 索引接口 123456789101112131415interface NestedCSS &#123; color?: string; nest?: &#123; [selector: string]: NestedCSS; &#125;&#125;const example: NestedCSS = &#123; color: 'red', nest: &#123; '.subclass': &#123; color: 'blue' &#125; &#125;&#125; 类 修饰符 public protected private 只读属性 readonly 123456789101112131415161718class Person&#123; public sex:string protected name:string private age:number constructor(sex:string,name:string,age:number)&#123; this.sex = sex this.name = name this.age = age &#125; public sayHello()&#123; console.log('helloworld') &#125; private sayLove()&#123; console.log('i love you') &#125;&#125;let woman:Person = new Person('女','新垣结衣',18) 命名空间 namespace 当声明两个相同的类时，使用namespace进行包裹，避免发生冲突123456789101112131415161718192021222324252627282930namespace Biology &#123; export interface Animal &#123; name: string; eat(): void;&#125;export class Dog implements Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; eat() &#123; console.log(`$&#123;this.name&#125; 吃狗粮。`); &#125; &#125; export class Cat implements Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; eat() &#123; console.log(`$&#123;this.name&#125; 吃猫粮。`); &#125;&#125;&#125; let dog: Biology.Animal;dog = new Biology.Dog('狗狗');dog.eat();]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-vuex]]></title>
    <url>%2F2018%2F05%2F03%2FVuex%2F</url>
    <content type="text"><![CDATA[Vuex定义: 和vue-router同为vue的核心工具 Vuex 是一个专为Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化注意:1.vuex 必须依赖vue文件，在工程化项目开发中，使用Vue.use(vuex) 创建:1.创建一个Vuex的实例2.将vuex的实例挂载到vm的根实例中12345678910111213141516171819202122232425262728293031323334353637const store = new Vuex.Store(&#123;state:&#123;count:0&#125;,getters:&#123; //理解成store的计算属性 str()&#123;console.log(arguments)&#125;&#125;,mutations:&#123;// 存储一些公共方法，以便其他组件重复调用// 它是vuex提供的一种用于修改state中数据的方式// 必须使用mutations的方法去修改state中的数据mu_add(state,n)&#123; // 第一个实参是默认的state // 第二个实参，是我们调用时，自己传的实参,只能写一个参数 // 若有多个参数，则放在一个对象和数组里面 // 通过 this.$store.commit('函数名','我们传递的参数') n = n || 1 state.count += n &#125;,&#125;,actions:&#123; // 可以提供异步方法，比如数据的axios的请求 ac_add(obj,n)&#123; // obj 是vuex封装好的对象，里面提供了commit方法 obj.commit('mu_add',n) setTimeout(()=&gt;&#123; obj.commit('mu_add',n) &#125;,1000) &#125; // 下面使用es6解构赋值语法，给参数1默认值 ac_add(&#123;commit&#125;,option)&#123; commit('mu_add',option) setTimeout(()=&gt;&#123; obj.commit('mu_add',option) &#125;,1000) &#125;&#125;&#125;) 使用:1.使用vuex中的数据,通过调用this.$store.state.count，使用vuex数据2.vuex中的数据全放在state中,当state中的某个数据发生改变时,所有用到该数据的地方全都会跟着改变,触发视图的更新3.通过this.$store.commit(&#39;函数名&#39;,options)，调用mutations中的方法，并默认传参state4.通过this.$store.dispatch(&#39;函数名&#39;,options)，调用actions中的方法，并默认传参obj对象,对象内置commit方法，再通过调用commit方法，触发mutations中方法执行，达到异步修改数据的目的1234567891011121314151617const son =&#123;template:'#son',data()&#123; return&#123; myCount:this.$store.state.count // 不建议将vuex里面的数据放在组件的data中储存 // 只会给myCount一个初始值，count的变化，并不会再引起view的变化 &#125;&#125;,computed:&#123; myCount()&#123; // 通常将数据放在组件的计算属性中，将属性名依赖于vuex中的数据 return this.$store.state.count &#125;, ...Vuex.mapState(['count','qqq'])&#125;&#125; Vuex中的辅助函数(工程化项目中，推荐使用) …mapState([‘count’,’qqq’]) 在组件内部挂载’count’和’qqq’属性 再将’count’映射为:this.$store.state.count …mapGetters([‘arr’]) 在组件内部挂载’arr’的计算属性 再将’arr’映射为: this.$store.getters.arr …mapMutations([‘mu_add’]) 在组件内部挂载’mu_add’方法 组件直接调用: this.mu_add(10),并传入我们需要的参数 等价于 : this.$store.commit(&#39;mu_add&#39;,10) 模块化定义:由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue数据管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime 安装走过的坑]]></title>
    <url>%2F2018%2F04%2F07%2FSublimeText3%20%2F</url>
    <content type="text"><![CDATA[Sublime Text 最好用的编辑器编辑器没用几个,好意思说自己是程序猿!sublime text 界面简洁大方 代码高亮提示简直舒适得不行 插件管理虽然不及VS,但是插件自定义功能是真心强大 软件体积小，打开项目速度是真的秒开 代码编辑的舒适感爆棚sublime安装使用过程中，参考网站 问题解决方案sublime解决方案 插件安装方案sublime插件官网 软件安装及插件安装注意: 网速很重要 软件下载地址sublime下载完成,安装过程一路点击默认即可 Package Control 安装插件前，需要安装一个插件管理器,复制以下代码,在sublime(ctrl + ` 快捷键呼出)控制台运行; 点击顶部导航栏 Perferences 看到弹框底部出现Package Control,证明安装成功; 若未成功,进入这个网站右面,进行手动安装,步骤也很简单,按照提示做即可; 手动安装Package Control123456import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack4]]></title>
    <url>%2F2018%2F04%2F06%2Fwebpack%2F</url>
    <content type="text"><![CDATA[网页中有哪些静态资源 JS .js .jsx .coffee .ts CSS .css .less .scss Images .jpg .png .gif .bmp .svg 字体文件 .svg .ttf .eot .woff .woff2 模板文件 .ejs .vue(这是在webpack中定义组件的方式) 网页中引入静态资源过多，会有什么问题 网页加载速度慢，因为我们要发起很多的二次请求 要处理错综复杂的依赖关系处理静态资源加载的问题 合并、压缩js.css文件 处理图片请求的时候，可以将图片设置成base64编码，这样会随着html结构一起加载 处理依赖关系，使用Gulp webpack什么是webpackwebpack 是前端的一个项目构建工具，它是基于node.js开发出来的一个前端工具 导入导出方式1.node: exports:导出 exports.obj = obj require:导入 let www = require(&#39;./a.js&#39;)123456789101112//a.js 文件let str = '哈哈哈'let obj = &#123; qqq:12&#125;exports.str = strexports.obj = obj// index.js 文件let www = require('./a.js')console.log(www)输出: str obj 2.es6(ECMAscript2015):1).export + import12345678910111213141516这种导出方式,在引入时,变量名需要跟导出的名字保持一致//a.jsexport let str = '哈哈哈'export let obj = &#123; qqq:12&#125;or:export &#123;str,obj&#125; import &#123;str,obj&#125; from './a.js' es6解构语法--------------------------------------------------// index.jsimport * as aaa from './a.js' console.log(aaa)输出: str obj这种导入方式，我们可以自定义导入接口的名字 2).export default + import123456//a.jslet str = '哈哈哈';export default str;//默认导出 strimport www from './a.js'这种导入方式也可以自定义接口名字 webpack4配置文件 webpack.config.js 入口、调试配置 12345678910111213141516171819202122232425262728293031323334353637383940414243const path = require('path');const pluginsConfig = require("./webpack.plguins.js");const rulesConfig = require("./webpack.rules.js");module.exports = &#123; entry: &#123; // 多入口文件 a: './src/js/index.js', b: './src/js/index2.js', jquery: 'jquery' &#125;, output: &#123; path:path.resolve(__dirname, 'dist'), // 打包多出口文件 // 生成 a.bundle.js b.bundle.js jquery.bundle.js filename: './js/[name].bundle.js' &#125;, plugins: pluginsConfig, devServer: &#123; contentBase: path.resolve(__dirname, "dist"), host: "localhost", port: "8090", open: true, // 开启浏览器 hot: true // 开启热更新 &#125;, // devtool: "source-map", // 开启调试模式 module:&#123; rules: rulesConfig &#125;, // 提取js，lib1名字可改 optimization: &#123; splitChunks: &#123; cacheGroups: &#123; lib1: &#123; chunks: "initial", name: "jquery", enforce: true &#125; &#125; &#125; &#125;&#125; webpack.plugins.js 插件配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const webpack = require("webpack");const path = require('path');const glob = require("glob");//消除冗余的cssconst purifyCssWebpack = require("purifycss-webpack");// html模板const htmlWebpackPlugin = require("html-webpack-plugin");// 清除目录等const cleanWebpackPlugin = require("clean-webpack-plugin");//4.x之前用以压缩const uglifyjsWebpackPlugin = require("uglifyjs-webpack-plugin");// 分离cssconst extractTextPlugin = require("extract-text-webpack-plugin");//静态资源输出const copyWebpackPlugin = require("copy-webpack-plugin");module.exports = [ new webpack.HotModuleReplacementPlugin(), // 调用之前先清除 new cleanWebpackPlugin(["dist"]), // 4.x之前可用uglifyjs-webpack-plugin用以压缩文件，4.x可用--mode更改模式为production来压缩文件 // new uglifyjsWebpackPlugin(), new copyWebpackPlugin([&#123; from: path.resolve(__dirname,"src/assets"), to: './pulic' &#125;]), // 分离css插件参数为提取出去的路径 new extractTextPlugin("css/index.css"), // 消除冗余的css代码 new purifyCssWebpack(&#123; // glob为扫描模块，使用其同步方法 paths: glob.sync(path.join(__dirname, "src/*.html")) &#125;), // 全局暴露统一入口 new webpack.ProvidePlugin(&#123; $: "jquery" &#125;), // 自动生成html模板 new htmlWebpackPlugin(&#123; filename: "index.html", title: "xxxx", chunks: ['a',"jquery"], // 按需引入对应名字的js文件 template: "./src/index.html" &#125;), new htmlWebpackPlugin(&#123; chunks: ['b'], filename: "index2.html", title: "page2", template: "./src/index2.html" &#125;)] webpack.rules.js 解析模块配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const extractTextPlugin = require("extract-text-webpack-plugin");module.exports = [ &#123; test: /\.css$/, // 不分离的写法 // use: ["style-loader", "css-loader"] // 使用postcss不分离的写法 // use: ["style-loader", "css-loader", "postcss-loader"] // 此处为分离css的写法 /*use: extractTextPlugin.extract(&#123; fallback: "style-loader", use: "css-loader", // css中的基础路径 publicPath: "../" &#125;)*/ // 此处为使用postcss分离css的写法 use: extractTextPlugin.extract(&#123; fallback: "style-loader", use: ["css-loader", "postcss-loader"], // css中的基础路径 publicPath: "../" &#125;) &#125;, &#123; test: /\.js$/, use: ["babel-loader"], // 不检查node_modules下的js文件 exclude: "/node_modules/" &#125;, &#123; test: /\.(png|jpg|gif)$/, use: [&#123; // 需要下载file-loader和url-loader loader: "url-loader", options: &#123; limit: 50, // 图片文件输出的文件夹 outputPath: "images" &#125; &#125; ] &#125;, &#123; test: /\.html$/, // html中的img标签 use: ["html-withimg-loader"] &#125;, &#123; test: /\.less$/, // 三个loader的顺序不能变 // 不分离的写法 // use: ["style-loader", "css-loader", "less-loader"] // 分离的写法 use: extractTextPlugin.extract(&#123; fallback:"style-loader", use: ["css-loader", "less-loader"] &#125;) &#125;, &#123; test: /\.(scss|sass)$/, // sass不分离的写法，顺序不能变 // use: ["style-loader", "css-loader", "sass-loader"] // 分离的写法 use: extractTextPlugin.extract(&#123; fallback:"style-loader", use: ["css-loader", "sass-loader"] &#125;) &#125; ]]]></content>
      <categories>
        <category>webpack4</category>
      </categories>
      <tags>
        <tag>特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-components]]></title>
    <url>%2F2018%2F04%2F02%2FVue-components%2F</url>
    <content type="text"><![CDATA[组件 - components 定义: 组件的出现，就是为了拆分vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可; 组件化和模块化的区别 模块化:是从代码逻辑的角度进行划分的,方便代码分层开发,保证每个功能模块的只能单一。 组件化:是从UI界面的角度进行划分的，前端的组件化，方便UI组件的重用。 创建组件的方式第一种 1.1 123let com1 = Vue.extend(&#123; template:"&lt;h3&gt;这是使用Vue.extend创建出来的组件&lt;/h3&gt;"&#125;) 1.2Vue.component(“mycom1”,com1) 引入的时候,使用标签进行渲染可以合并成一步: 123Vue.component('mycom1',Vue.extend(&#123; template:"&lt;h3&gt;这是使用Vue.extend创建出来的组件&lt;/h3&gt;"&#125;)) 第二种12345注意:无论是哪种方式创建出来的组件，组件的template属性指向的内容， 必须有且只有唯一的一个根元素 Vue.component('mycom2',&#123; template:'&lt;div&gt;&lt;h3&gt;这是使用Vue.extend创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;' &#125;) 第三种Vue.component(&#39;mycom2&#39;,{template:&#39;#temp1&#39;}) 在APP控制的区域外，定义一个ID为temp1的template标签，在标签元素节点可以写你想要的代码 组件中的data123456789101112131415161718192021注意：data必须是一个函数，而且函数必须返回一个对象， 模板中的元素行内指令可以调用，这里返回对象的意义， 当调用多次同一个组件的时候，虽然返回对象内容相同， 但是是引用数据类型，空间地址不一样， 组件之间的数据完全独立，不会因为其他组件数据的变化而变化let vm2 = new Vue(&#123; el:'#app2', data:&#123; &#125;, components:&#123; login:&#123; template:'#temp1', data:function()&#123; return&#123; msg:'' &#125; &#125; &#125; &#125; &#125;) Vue提供的4个标签属性 transitiontransition-grouptemplatecomponent 子父组件 如何相互传值1&lt;son :parentmsg = "msg" @parentfuc123 = "fn"&gt;&lt;/son&gt; 父传子父组件通过绑定自定义属性，向子组件内传入数据子组件通过props:[‘自定义属性名’]，接收父组件传进的数据 具体实现方式 =&gt; :parentmsg = &quot;msg&quot; (parentmsg为自定义属性名，msg为父组件内的数据)使用过程中注意:1.传入的数据可以是基本数据类型，也可以是引用数据类型;2.可以是父组件中的data数据，也可以是methods中的方法(但是我们需记住:VUE不希望我们以自定义属性的方式，传入methods中的方法);3.不能直接修改props中父组件传进来的数据,虽然子组件可以渲染出修改后的数据，但是只要父组件视图发生变化，就会重新覆盖子组件的内容;4.但是，当我们传入一个引用数据类型，在原地址修改数据时不会引起报错,能成功修改父组件的数据;5.子组件使用父组件的数据是一个单向的数据流;12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;son :parentname = 'val' :myname ="name" :arr = ary v-for = "val in ary" :key = "val"&gt; &lt;/son&gt;&lt;/div&gt;&lt;template id="son"&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;parentname&#125;&#125;&lt;/h2&gt; &lt;h3 v-for = "i in arr"&gt;&lt;/h3&gt; &lt;button @click="fn"&gt;这个按钮点击&#123;&#123;n&#125;&#125;次&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;let son =&#123; template:'#son', props:['parentname','myname','arr'], data()&#123;return&#123;n:0&#125;&#125;, methods:&#123; fn()&#123; this.n++ this.arr.push('node') &#125; &#125;let vm = new Vue(&#123; el:'#app', data:&#123; name:'hello', ary:['css','js','vue'] &#125;, components:&#123; son &#125; 子传父父组件通过绑定自定义事件，向子组件内传入methods方法子组件通过调用this.$emit(‘自定义事件名’，第一参数,第二参数…)方法，接收父组件方法，并通过第一参数，第二参数…，同时向父组件内传值 具体实现方式 =&gt; @parentfuc123 = &quot;fn&quot; (parentfuc123为自定义属性名，fn为父组件内的methods方法)123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;son @qqq = "change"&gt;&lt;/son&gt;&lt;/div&gt;&lt;template id="son"&gt; &lt;div&gt; &lt;input type="text" v-model="n"&gt; &lt;button @click = "fn"&gt;通过自定义事件改变父组件的name&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;let son = &#123; template:'#son', data()&#123;return&#123;n:''&#125;&#125;, props:['aaa'], methods:&#123; fn()&#123;this.$emit('qqq',this.n)&#125; &#125;&#125;let vm = new Vue(&#123; el:'#app', data:&#123;name:'hello'&#125;, components:&#123; son &#125;, methods:&#123; change(val)&#123; this.name = val &#125; &#125;&#125;) 其它传值方式 父组件可使用 this.$children[0] this.$refs.son 子组件可使用 this.$parent注意:1.当组件为全局注册时，其他组件使用时，不必再，在自己内部注册一遍2.父组件最早可以在mounted()这个生命周期函数内，调用$children这个方法3.先执行父组件的created(),再执行子组件的created(),然后执行子组件的created(),最后执行父组件的created() 自定义组件为什么要使用自定义组件:有时候，当我们对原生提供的样式不满意时，可以使用自定义组件，组件的样式我们可以自行设置123456789101112131415&lt;div id = "app"&gt; &lt;my-input v-model = 'name'&gt;&lt;/my-input&gt; &lt;!-- 等价于 &lt;my-input :value = 'name' @input&gt;&lt;/my-input&gt; --&gt;&lt;/div&gt;&lt;template id = "son"&gt;&lt;input :value = 'value' @input = '$emit('input')'&gt;&lt;/input&gt;&lt;/template&gt;&lt;script&gt;let son = &#123; template:'#son', props:['value']//value 是规定死的，不能改写&#125;&lt;/script&gt; 插槽用法: 将slot标签放置在组件的模板中，那么在以组件名生成标签内部的所有内容，会替换slot标签的位置注意:1.slot 的name属性是控制 要去显示哪一部分的一个功能,写时默认default;2.name 对应的是 模板中slot=xxx 的 xxx;3.模板中若有与name值对应的元素；则 slot标签包含的代码不会显示出来;4.否则，可以显示slot标签包含的内容123456789101112131415161718192021222324252627282930&lt;div id = "app"&gt;&lt;son&gt; &lt;div slot='qqq'&gt;hahaha&lt;/div&gt; &lt;h2&gt;hehehe&lt;/h2&gt; &lt;div&gt;24324&lt;/div&gt; &lt;div slot='www'&gt;111&lt;/div&gt; &lt;div slot='www'&gt;222&lt;/div&gt;&lt;/son&gt;&lt;/div&gt;&lt;template id = "son"&gt;&lt;!-- slot 相当于把组件标签包含的所有内容 放到slot标签的位置 --&gt;&lt;div&gt;&lt;slot name = "qqq"&gt;&lt;/slot&gt; //显示:hahaha&lt;h1&gt;这是个子组件&lt;/h1&gt;&lt;slot&gt;&lt;/slot&gt;//显示：hehehe 只能显示没有slot属性的标签元素// 24324&lt;slot name='www'&gt; &lt;div name='2342342'&gt;777&lt;/div&gt;&lt;/slot&gt;//显示: 111 222&lt;slot name='eee'&gt; &lt;div name='2342342'&gt;666&lt;/div&gt; &lt;slot name='www'&gt;&lt;/slot&gt;&lt;/slot&gt;//显示:666 111 222 //原因:上面标签内部中，并没有slot = "eee"属性的元素，所以会显示&lt;slot&gt;&lt;/slot&gt;标签内部的默认值&lt;/div&gt;&lt;/template&gt; component 动态组件component 是一个内置动态组件; is属性用控制显示哪个子组件keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和transition相似,keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。主要用于保留组件状态或避免重新渲染1234567&lt;div id="app"&gt; &lt;button @click='son="son1"'&gt;son1&lt;/button&gt; &lt;button @click='son="son2"'&gt;son2&lt;/button&gt; &lt;keep-alive&gt; &lt;component :is='son'&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router]]></title>
    <url>%2F2018%2F03%2F29%2FVue-router%2F</url>
    <content type="text"><![CDATA[路由 v-router前端路由和后端路由的区别 后端路由:对于普通网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源 前端路由:对于单页面应用程序(SPA)来说，主要是通过URL中的hash值来实现不同页面之间的切换；同时，hash有一个特点:HTTP请求中不包括hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现 在单页面应用程序中，这种通过hash改变切换页面的方式，称作前端路由（区别于后端路由） 创建一个路由对象及语法规则（不适用于webpack）1234567891011121314151617181920212223242526&lt;router-link to = "/home" tag = 'button' active-class = "current"&gt;主页&lt;/router-link&gt;&lt;script src = 'https://unpkg.com/vue-router@2.0.0/dist/vue-router.js'&gt;&lt;/script&gt; //第一步安装路由，要在vue.js之后 // 引入后，在window全局对象中，就有了一个路由的构造函数，叫做VueRouter let routes = [ // =&gt; 路由匹配的规则 &#123;path:'/login',component:login&#125;, &#123;path:'/',redirect:'/login'&#125; //=&gt; 重定向，强制页面默认在login页面上 // =&gt; 1.每个路由规则都是一个对象，这个队则身上必须有两个属性 // =&gt; 2.属性1: 是path，表示监听这个路由地址 // =&gt; 3.属性2: 是component，表示前面匹配是path， 则展示对应的component对应的组件 // =&gt; 注意: component的属性值必须是一个模板对象,不能是组件名称 ] &#125;) const router = new VueRouter(&#123; routes, linkActiveClass:'cur' // 把所有的被选中路径的类名改成 cur // active-class的优先级高于统一设置的优先级 &#125;) 通过:router:routerObj ,将路由对象挂载到vm实例上; router-view: 将符合path的组件展示在页面上，若出现多个view，则会重复展示符合条件的组件; router-link: router-link 相当于a标签，点击，跳转到指定的hash值; active-class: 控制选中时，对应路径组件的样式类名; 路由传参的两种方式 query传参 表现形式 : /home?id=10&amp;name=zs 路由映射表不用改动; 通过 ? 传参 通过 :to = &quot;{path:&#39;/home&#39;,query:{}}&quot; 或者 :to = &quot;{name:&#39;&#39;,query:{}}&quot;传参,可以传递组件内的变量 this.$route.query.xxxx获取传递的参数值 使用name，不会把路径写死，可以任意传参12345678910&lt;router-link to = "/login?id=10&amp;name=zs"&gt;登录&lt;/router-link&gt;&lt;router-link :to="&#123;path:'/login',query:&#123;id:123&#125;"&gt;登录&lt;/router-link&gt;&lt;router-link :to="&#123;name:'login123',query:&#123;id:123&#125;"&gt;登录&lt;/router-link&gt;const routes = [ &#123;path:'/login', name:'login123', component:login &#125;]console.log(this.$route.query.id) params传参 路径传参 表现形式 : /register/333?id=123 使用路径传参，只能使用name来表示要跳转到哪个路径; 在路由映射表中添加 /:变量 的形式; :to =&quot;{name:&#39;&#39;,params:{变量：&#39;&#39;}}&quot; this.$route.params.xxxx 获取 123456789&lt;router-link :to="&#123;name:'register123',query:&#123;id:123&#125;,params:&#123;qqq:333&#125;&#125;"&gt;注册&lt;/router-link&gt;const routes = [ &#123;path:'/register/:qqq', name:'register123', component:register &#125; ] console.log(this.$route.params.qqq) console.log(this.$route.query.id) 注意原理: 1)当我们通过传参时，vue都会通过设置的path，解析出一个正则regexp,去匹配fullpath 2)当fullpath是?传参时，匹配失败，params为空，但是可以通过query获取 3)当我们通过设置path占位符时，捕捉到fullpath，可以通过params获取 路由的嵌套 使用children属性，实现子路由，同时，子路由的path前面，不要带’/‘,否则以根路径开始请求，这样不方便客户理解URL路径123456789101112let router = new VueRouter(&#123; routes: [ &#123; path:'/account', component:account, children:[ &#123;path:'login',component:login&#125;, &#123;path:'register',component:register&#125; ] &#125; ] &#125;) 命名视图的用法1&lt;router-view name = "left"&gt;&lt;/router-view &gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-transition]]></title>
    <url>%2F2018%2F03%2F29%2FVue-transition%2F</url>
    <content type="text"><![CDATA[Vue动画在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js列表动画效果 transition这个过渡， 内里只能有一个根元素，且只对根元素起作用 duration: 控制Vue设置的类名存在的时间，但是动画效果还是C3设定的时间完成，duration只是延长类名存在时间 li{ background-color: hotpink; transition: all 1s ease; }定义动画开始和结束前的状态.v-enter,.v-leave-to{ transform: translateY(30px); }定义动画开始和结束过程中的状态.v-enter-active,.v-leave-active{ transition: all 0.7s ease; }1.定义元素位置除了display：none外，移动的效果2.move和leave-active 必须结合起来使用3.在结构元素节点上定义 appear 属性 使初始视图具有出场的效果.v-move{ transition: all 0.7s ease; }.v-leave-active{ position: absolute; }]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>transition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生命周期]]></title>
    <url>%2F2018%2F03%2F27%2FVue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Vue实例的生命周期 什么是生命周期:从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子:就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类: 创建期间的生命周期函数: beforeCreate : 实例刚在内存中被创建出来，此时，还没有初始化好data和methods属性 created : 实例在内存中创建OK，此时data和methods已经创建OK，此时还没有开始编译模板 beforeMount : 此时已经完成了模板的编译，但是还没有挂载到页面中 mounted : 此时，已经将编译好的模板，挂载到页面指定的容器中显示 运行期间的生命周期函数: beforeUpdate : 状态更新之前执行函数。此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated : 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了 销毁期间的生命周期函数: beforeDestroy : 实例销毁之前调用，在这一步，实例仍然完全可用。 destroyed : Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会被解除绑定，所有的事件监听器都会被移除，所有的子实例也会被销毁]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-mvvm解析]]></title>
    <url>%2F2018%2F03%2F26%2FVue-mvvm%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Vue.js 的细节 Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节： Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。12345678910111213141516171819202122232425 let person = &#123; 'sex':'girl', 'name':'晓甜甜', 'address':'XXX公寓' &#125; function observe(obj,prop,val)&#123; Object.defineProperty(obj,prop,&#123; enumerable: true, configurable: true, get:function()&#123; return '此人住在'+val &#125;, set:function(newVal)&#123; val = newVal console.log('此人换新家了，现在在' + newVal) &#125; &#125;) &#125; observe(person,'address',person['address']) console.log(person.address) person.address = 'YYY小区'//控制台打印 会触发两次31行代码//此人住在XXX公寓//此人换新家了，现在在YYY小区 Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。 Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。 Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。 Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue指令及基础知识]]></title>
    <url>%2F2018%2F03%2F26%2FVue-%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[VUE 数据驱动:操作DOM JS的数据类型 基本 和 引用 改变原数组 —&gt; 数组的变异 pop push shif unshift reverse sort splice(n,m,x,y,z) 不改变原数组 —&gt; slice(n,m) concat indexOf join(‘+’) toString() 数组的迭代方法 forEach map:renturn什么值，就往新数组添加新属性，若没有return值，就添加undefined filter 1)filter的回调函数中return值，若是true，则把当前迭代的项复制一份到新数组arr中 2)filter的返回值是新数组arr some: 1)回调函数中只要有一个回调函数返回的是true，则整个some 返回值就是ture 2)只要某个项满足条件，就不在进行迭代 every: 1)回调函数，每一个都是true，every的返回值才是true 2)换句话说就是只要有一个是false ，整个结果就是false reduce((prev,next)=&gt;):结果就是最后一次迭代的return值 find: 找到满足条件的第一项 includes(item,index)从index索引值开始查找 找到就是true 找不到就是false NODE基础命令 package.json 是项目的依赖表单 dependencies:存储的都是生产环境的依赖 devdependencies:储存的都是开发环境的依赖 scripts:中存储的都是要执行的命令对应的代码 npm run hello : 对应的要执行hello对应的代码 npm i vue –save:在项目中添加依赖，安装依赖 npm i yarn -g : 全局安装yarn，以后可以使用yarn代替npm 去安装一些依赖 VUE - M-V-VM 1.vue 双向数据绑定 ；渐进式；框架 2.视图 V 数据 M VM 3.视图改变 数据自动更新 4.数据更新 视图自动更改 5.渐进式: SPA 单页面开发 核心:vue.js vue-router控制路由 vuex 处理数据 axios 解决请求 声明式 编程式 forEach 声明式 for() 编程式 框架 框架:自己写的代码被框架调用 Vue React Angular BootStrap 库: 自己调用库的代码 Vue的指令 1.v-model: 是vue的指令 name是实例的变量 指令是指让对应的元素做某件事 2.v-text : 展示对应的文本 3.v-once : 对应的标签只渲染一次 1~3指令都是行内属性 4.v-html : 把值中的标签渲染出来 5.v-cloak : 解决渲染闪烁问题[v-cloak] {display: none;} &lt;div v-cloak&gt;{{ message }}&lt;/div&gt; 6.v-show : 控制元素的display:ngone 属性 7.v-on:click : 给元素绑定事件 简写 @click = &#39;fn&#39; 8.v-keyup.enter = ‘fn’ : 给元素绑定键盘事件 9.v-bind:绑定样式 对象 路径 缩写: : 10.v-for : 循环显示元素的,可以循环数组，也可以循环对象、字符串、数字 ，v-for优先级比v-if/else的优先级高，先渲染v-for 11.v-if / v-else-if /v-else :直接不加载元素,先做循环再做判断v-model指令 实现 数据和视图 双向绑定 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt;等表单元素和components组件 单个复选框，绑定到布尔值： 1&lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; CheckBox 多个复选框,绑定到同一个数组：check = [] CSS HTML JS check 若为 [] 一个数组 则3个input框能联系在一起,选择input框，则会在数组中push表单框中的value值 12345radio 单选框 &lt;!-- 多个input绑定同一个变量即可 --&gt; &lt;input type="radio" v-model="fruit" value="1"/&gt;🍎 &lt;input type="radio" v-model="fruit" value="2"/&gt;🍌 &lt;input type="radio" v-model="fruit" value="3"/&gt;🍊 v-model实现数据双向绑定的原理get方法 获取数据，当属性依赖于其他data中属性时，其他数据改变，才会触发这个方法，但必不会触发set方法 最终值是由get方法决定的123456789var obj = &#123;&#125;;Object.defineProperty(obj,'name',&#123; get()&#123;return 123&#125;, set(val)&#123; console.log(val) &#125;&#125;)obj.name = 333;console.log(obj.name) set方法 使用v-model:进行数据的双向绑定 只有点击改变值的时候，才会触发这个方法，触发这个方法必然触发了get方法 修饰符事件修饰符 self: 只有点击元素本身的时候才触发 stop:阻止冒泡 prevent:阻止默认事件 once: 对应的函数只触发一次 capture: 让事件在捕获阶段触发 passive : 优先执行默认事件，在执行绑定的函数，优化移动端性能，只对滚动行为有效v-model修饰符 number : 将字符串转化为数字 类似 parsefloat的效果 trim : 自动去除首尾空格 自定义全局键码Vue.config.keyCodes.f2 = 113 =&gt; 在模板中可以这样使用 `@keyup.f2 = fn’’`· 过滤器1&#123;&#123;money | changeM&#125;&#125; 管道符前边是要处理的数据，后边是处理的参数，最终展示的是函数的返回值 过滤器是可以连续使用的，下一个过滤器的返回值，是上一个过滤器的返回值 全局过滤器和私有过滤器，全局过滤器任何组件都可以调用，私有过滤器只有定义过滤器的组件可以调用 filter 中的方法 可以重名，不会被冲掉，但尽可能不要重名123456Vue.filter('过滤器名称'，function()&#123;&#125;) 全局过滤器 console.log(this) //=&gt; this 指向window在vm实例中定义filters:&#123; '过滤器名称':functon()&#123;&#125;&#125; 私有过滤器 侦听器 Watch 异步用监听,但是比较耗性能，能够深层监听，能够返回oldV 和 newV 两个值供实例调用 深层监听的属性必须是有set和get方法的属性值 当监听一个数组的时候，若数组地址不发生改变，那么不会触发watch的方法 Watch还可以监听到路由的变化 具有局限性，当监听的数据过多时，不适合使用watch方法 计算属性 Computed 同步用计算属性，但依赖性太强，用到get/set方法 定义的方法，挂载在vm的实例，不能跟methods和data重名，但是现在不报错，但是不能用，因为methods中的方法会把computed中的方法冲掉 只要name不发生改变，name2就不发生改变 name2用到谁，就依赖谁 conputed计算属性，具有缓存机制，若数据发生改变，会重新计算属性，若只是重复调用，则不会触发computed方法 123456789101112131415computed:&#123; name2()&#123; return this.name.split('').rerverse().join('') &#125;, name3()&#123; get()&#123; console.log(this.name) return 123 &#125;, set(val)&#123; // 给name3赋值的时候会触发, set函数 // val 是外界 &#125; &#125;&#125; computed / watch / methods 三者的区别 computed : 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算，主要当做属性来使用 watch : 一个对象，键是需要观察的表达式，值是对应的回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是methods和computed的结合体 methods : 表示一个具体的操作，主要书写业务逻辑自定义全局指令 使用directive定义全局的指令 其中参数1：指令的名称，注意，在定义的时候，指令的名称前面，不需要加 -v 前缀 但是在调用的时候，必须在指令名称前加上 v- 前缀 进行调用 参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 12345678910111213 bind:function(el)&#123; =&gt;每当指令绑定到元素身上的时候，会立即执行这个bind函数，只执行一次 //1.注意：在每个函数中，第一个参数永远是el，表示被绑定的那个元素，这个el参数以一个原生JS对象 //2.在元素刚绑定指令的时候，还没有插入到DOM中，这时候，调用focus方法没有起作用 //3.因为，一个元素只有插入到DOM中，才能获取焦点 //el.focus() &#125;, inserted:function(el)&#123; =&gt;表示元素被插入到DOM中的时候，触发这个inserted函数，触发一次 el.focus() &#125;, updated:function(el)&#123; =&gt;每当VNode更新的时候，会执行updated函数，可能会被触发多次 &#125; &#125;) 自定义指令简写:Vue.directive(&#39;focus&#39;,function(el,binding){}) 钩子函数 钩子函数的参数: 指令钩子函数会被传入以下实参 1.el : 指令所绑定的元素，可以用来直接操作 DOM 2.binding: name: 指令名，不包括 v- 前缀; value:指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2; expression:字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 &quot;1 + 1&quot;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的事件]]></title>
    <url>%2F2017%2F05%2F12%2FJS%E4%BA%8B%E4%BB%B6%20%E2%80%93DOM0%20%E2%80%93DOM2%E2%80%93%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E2%80%93%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"><![CDATA[事件 –DOM0 –DOM2–发布订阅–拖拽 什么是事件? 指的是是一件事或一个行为 事件 鼠标事件 click 单击 dblclick双击 大约300ms内连续点击两次 mouseover 鼠标滑进 冒泡阶段 先自己触发 后父辈触发 mouseout 鼠标滑出 mouseenter 鼠标移入 捕获阶段 先父辈触发 后自己 mouseleave鼠标移出 mousemove 鼠标滑动（过程） mousedown 鼠标按下（不动） mouseup鼠标抬起 mousewheel鼠标滚轮移动 键盘事件 应用元素：textarea input window html body等都可绑定键盘事件 keydown (键盘按下时触发) keyup（键盘抬起来时触发） keypress（按下时并抬起来时触发，系统键是监听不到的） 系统事件 onload 加载页面资源后 onresize（浏览器窗口发生改变时触发） onscroll（滚动条发生改变时触发） DOMContentLoaded (dom元素加载完了后再触发) 表单元素 onfoucs 获取焦点（光标）时触发 onchange（表单元素发生改变,并且失去焦点后时，才能触发） oninput（移动端，表单输入时触发，只要内容发生改变就会触发） onblur（失去焦点，表示光标离开表单元素时触发） onpropertychange 只要内容发生改变，就会触发 移动端事件 ontouchstart触碰到元素触发 ontouchend离开元素触发 ontouchmove必须在点击的情况，来回移动，才能触发函数 onclick 有大约300ms的延迟 事件绑定：事件行为发生时去做的具体的事情 行为和具体事情要绑定起来这就是事件绑定呀事件对象12345678box.onclick = function(e)&#123;e:事件对象 当执行事件绑定的方法时，浏览器会将事件对象作为实参传递到方法中e.target:事件源 元素对象e.clientX:鼠标点击的位置距离 可视窗口的 左偏移e.clientY:鼠标点击的位置距离 可视窗口的 上偏移e.pageX:鼠标点击的位置距离 BODY的 左偏移e.pageY:鼠标点击的位置距离 BODY的 上偏移&#125; 兼容IE低版本浏览器的写法12345box.onclick = function ()&#123; e = e || window.event var tar = e.target || e.srcElement e.preventDefault ? e.preventDefault():e.returnValue = false 阻止默认行为&#125; 操作这个box上下左右移动 键盘事件1234567891011121314151617enter回车键 ： 13window.onkeydown = function (e)&#123; switch(e.keyCode)&#123;//键盘码 case 37 : box.style.left = parseFloat(box.style.left) - 10 + 'px' break case 38 : box.style.top = parseFloat(box.style.top) - 15 + 'px' break case 39 : box.style.left = parseFloat(box.style.left) + 25 + 'px' break case 40 : box.style.top = parseFloat(box.style.top) + 15 + 'px' break &#125; &#125; 给一个元素（如：div，ul，li）绑定一个行为（如：onclick、onmouseover）等于一个方法 方法里写要执行的东东 默认事件 先执行绑定的事件，再执行默认事件 注：天生自带默认事件的 keydown和input和keyupinput事件是在down之后，up之前触发，阻止默认后，不在触发input； a标签默认进行跳转 锚点定位功能 img绑定鼠标事件后，会触发原生鼠标拖拽事件 移动端默认事件:touchmove 阻止默认事件：document.addEventListener(‘touchmove’,function(){},{passive:false}) （在PC端时需注意，用此方式让绑定的touchmove默认事件 - 即滚动事件 先执行） 12345678910111213141516&lt;div&gt; &lt;img id = 'img' src = 'www.baidu.com'/&gt;&lt;/div&gt;img.onmousemove = function(e)&#123; e.preventDefault() &#125;&lt;a href="https://baidu.com" id="oa"&gt;百度一下&lt;/a&gt; &lt;!-- 正常跳转 --&gt;&lt;a href="javascript:;" id=""&gt;百度两下&lt;/a&gt; &lt;!-- 禁止页面跳转 --&gt;&lt;a href="" id=""&gt;百度三下&lt;/a&gt; &lt;!-- 刷新页面 --&gt;&lt;a href="Javascript :void(0);" id=""&gt;百度四下&lt;/a&gt; &lt;!-- 禁止页面跳转 --&gt;oa.onclick = function (e)&#123;e.preventDefault();alert(111)&#125; 阻止a标签这种默认行为 事件传播 事件冒泡 0级事件是在冒泡阶段触发的 阻止冒泡：e.stopPropagation||e.cancelBubble = true 事件绑定 绑定分为DOM0级事件绑定 和 DOM2级事件绑定 是按照绑定的顺序执行方法 低版本IE浏览器会乱序 DOM0级事件绑定 传统的事件绑定odiv.onclick=function问题 ： DOM0级事件绑定 对同一元素，同一事件绑定多个行为时，后面的行为会覆盖前面的行为，最终只执行最后一次绑定的行为 DOM2级事件绑定 较于0级事件绑定，优点是可以绑定多个方法第一个参数 事件类型第二个参数 事件绑定行为第三个参数 事件传播的方式oiv.addEventListener(“click”,function ( ) {alert(1)},false);true捕获阶段触发 false在冒泡阶段触发 DOM0 和 DOM2 在事件绑定上的区别 1.机制不一样 dom0采用的是给私有属性赋值，所以只能绑定一个方法 dom2采用的是事件池机制，所以能绑定多个不同的方法 2.移除的操作 box.onclick = null dom0移除 dom2 在移除的时候，必须清楚要移除哪一个方法，才能在事件池中移除，所以基于DOM2做事件绑定，我们呢要有“瞻前顾后”的思路，也就是绑定的时候考虑一下如何移除（技巧：不要绑定匿名函数，都绑定实名函数） 3.DOM2事件绑定增加了一些DOM0无法操作的事件行为，例如：DOMContentLoaded事件，（当页面中的HTML结构加载完后才能就会触发执行） IE低版本单独拿出来 IE低版本浏览器绑定方式 IE 6 ~ 8 DOM2级事件绑定odiv.attachEvent(“onclick”,function () {alert(666)})IE 低版本浏览器移除绑定odiv.detachEvent(“onclick”,function () {alert(666)}) DOM事件绑定移除 DOM0级事件移除：odiv.onclick=null DOM2级事件移除 odiv.removeEventListener(“click”,function () {alert(1)},false);移除123/*var odiv=document.getElementById('div1')odiv.onclick=function (e) &#123;&#125;*/ 事件对象 (e)浏览器天生存在的 浏览器记录了事件相关的信息 clientX 到窗口左边的距离 clientY 到窗口上边的距离 pageX 到文档左边的距离 pageY 到文档上边的距离 pageY相当于clientY+(document.documentElement.scrollTop||document.body.scrollTop) type 事件类型 target 事件源 也就是事件绑定的元素 preventDefault 阻止默认行为 IE低版本浏览器 retuenValue=true stopPropagation 阻止冒泡 IE低版本浏览器 cancelBubble=true IE6~8用Window.event 接收事件对象 e = e || Window.event 事件委托 一个容器中，有很多后代元素的点击行为都要处理一些事情，之前的思路是把需要操作的元素一一获取，然后再一一做事件绑定，在不同的方法中完成不同的需求，现在不用了，基于事件的冒泡传播机制，我们可以只给容器的Click绑定一个方法，这样不管以后点击的容器中的哪一个后代元素，都会通过事件的冒泡传播机制，把容器的Click行为触发，把绑定的方法执行，我们在方法执行的时候，根据事件对象中的事件源（e.target）来做不同的业务处理即可，这种机制既是事件委托机制1）容器中很多后代元素的某个行为要进行操作，委托给容器处理是不错的选择2）元素是动态绑定的3）需求是除了xxx，剩下的操作都是干同样的事情业务(此时把点击行为的操作委托给BODY，事件源是xxx做什么，不是同一做什么)……….. 原生拖拽拖放的流程：选中 == &gt; 拖动 == &gt; 释放 选中过程: 在HTML5标准中，为了使元素可拖动，把draggable属性设置为true。文本、图片和链接是默认可以拖放的，它们的draggable属性自动被设置成了true。图片和链接按住鼠标左键选中，就可以拖放。文本只有在被选中的情况下才能拖放。如果显示设置文本的draggable属性为true，按住鼠标左键也可以直接拖放。draggable属性：设置元素是否可拖动。 语法：1234&lt;element draggable="true | false | auto" &gt;true: 可以拖动false: 禁止拖动auto: 跟随浏览器定义是否可以拖动 拖动过程: 每一个可拖动的元素，在拖动过程中，都会经历三个过程，拖动开始 ==&gt;拖动过程中 ==&gt; 拖动结束 dragenter和dragover事件的默认行为是拒绝接受任何被拖放的元素。因此，我们必须阻止浏览器这种默认行为。e.preventDefault() 针对对象 事件名称 说明 被拖动的元素 dragstart 在元素开始被拖动时候触发 drag 在元素被拖动时反复触发 dragend 在拖动操作完成是触发 目的地对象 dragenter 当被拖动元素进入目的地元素所占据的屏幕空间时触发 dragover 当被拖动元素在目的地元素内时触发 dragleave 当被拖动元素没有放下就离开目的地元素时触发 释放过程: 到达目的地之后，释放元素事件 针对对象 事件名称 说明 目的地对象 drop 当被拖动元素在目的地元素里放下是触发，一般需要取消浏览器的默认行为 发布订阅模式（观察者模式） 思想：准备一个容器，把达到指定时间点要处理的事情，事先一一的增加到容器中（发布计划，并且向计划表中订阅方法），当到达指定时间点，通知容器中的方法依次执行即可12345678let $plan = $.Callbacks()// 创建一个空的计划表 空容器 =&gt; $plansetTimeout(function ()&#123; $plan.fire(10,20)//=&gt;fire 就是通知容器中的方法按照顺序依次执行的: 10和20是执行容器中每一个方法的时候，都会给他们出阿迪两个参数值&#125;，1000)$plan.add((x,y)=&gt;&#123;...&#125;)//=&gt;add是向容器中增加方法，remove是从容器中移除方法$plan.add((x,y)=&gt;&#123;...&#125;)$plan.add((x,y)=&gt;&#123;...&#125;) bind源码 利用形成的不销毁的栈内存，用来存值及保护变量不受全局的污染 外层套个函数用来存储我们以后需要的值，return一个匿名函数，编程思想这种编程思想我们称作柯理化函数bianc`Function.prototype.mybind = function mybind (context,…arg){ let _this = this return function anonymous(…innerArg){ _this.apply(obj,arg.concat(innerArg)) } }document.body.onclick = fn.mybind(obj,10,20)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的继承方式]]></title>
    <url>%2F2017%2F05%2F12%2FJS%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[类的继承和多态 封装: 把实现一个功能的代码放在一个函数中封装起来，以后再想实现这个功能的时候，我们不需要重新的编写代码了，只需要执行对应的函数即可，我们把这种机制就称之为”函数的封装”–&gt;低耦合高内聚:减少页面中的冗余代码,提高代码的重复使用率12345function fn()&#123; 实现功能的代码&#125; fn(); fn(); 多态:后台语言[java、C#、ASP.net、php…]中的多态：重载、重写重载(Reload)：多个方法,方法名相同,参数的个数或者参数的类型不一样重写(Rewrite)：子类重写父类的方法1)JS中如果函数名相同了,后面的会把前面的函数给覆盖掉,所以JS中不存在重载 fn(); -&gt;2 functionfn(){console.log(1);}2)JS中的多态指的是一个方法的多种形态:一个方法,我们通过传递进来的参数值的不一样,实现不一样的功能根据传递的n和m的值不一样,我们获取的结果也不一样,例如:如果执行的时候不传递任何的参数,返回[0-1)之间的随机小数,如果传递了两个值1/10,返回的是[1-10]之间的随机整数12345678910111213function getRandom(n,m)&#123; n=Number(n); m=Number(m); if(isNaN(n) || isNaN(m))&#123; returnMath.random(); &#125; if(n&gt;m)&#123; n=m+n; m=n-m; n=n-m; &#125; return Math.round(Math.random()*(m-n)+n); &#125; 继承:JS中常用的继承有以下几种方式(子类想要继承父类中的属性和方法)1)原型链继承(我们项目中最常用的一种继承方式)A、子类的原型指向父类的一个实例即可-&gt;原理不是把父类中的方法直接的继承复制过来一份,而是通过原型链的查找机制一级级的向上查找使用的B、原型继承是把父类中私有和公有的属性和方法都当做子类中公有的C、子类可以通过原型链的查找机制把父类原型上的属性和方法进行添加、修改、删除,如果这样操作完成后,我们父类的其他实例都会受到影响-&gt;子类重父类的方法-&gt;类的重写,例如:c.proto.proto.getX=function(){} 相当于子类重写了父类原型上的公有的方法12345function Parent()&#123;this.x = 100;&#125;Parent.prototype.getX =function () &#123;console.log(this.x);&#125;;function Children()&#123;this.x = 200;&#125;Children.prototype = newParent;var c = newChildren; ####2)call继承（借用构造函数继承）A、在子类的函数体中,把父类当做一个普通的函数执行,让父类执行的时候里面的this变为子类的一个实例,这样就相当于直接的给子类的实例增加私有的属性和方法B、call继承只能继承父类私有的属性和方法,而且继承过来后也是子类实例自己私有的C、call继承是直接的把父类中的私有属性和方法相当于克隆一份直接的给子类123456789function Parent()&#123;this.x = 100;this.writeX = function () &#123;&#125;&#125;Parent.prototype.getX =function () &#123;console.log(this.x);&#125;;function Children()&#123; //this-&gt;Children的实例c Parent.call(this);//把Parent当做普通的函数执行,让里面的this变为c-&gt;在执行的时候相当于c.x=100、 c.writeX=function...&#125;var c = newChildren;var d = newChildren;console.log(c.writeX ===d.writeX);//--&gt;false 3)冒充对象继承A、在子类的函数体中,我们创建一个父类的实例,然后把这个实例当做一个普通的对象进行遍历,在每一次遍历的时候,把父类中私有/公有的属性和方法,都当做子类实例的私有属性和方法进行存储(使用 for in 循环可以遍历出类私有属性和自定义的属性方法)B、父类的私有和公有都可以继承,而是是相当于复制了一份继承过来的C、继承过来的都是子类实例私有的属性和方法12345678910111213function Parent()&#123;this.x = 100;this.writeX = function () &#123;&#125;&#125;Parent.prototype.getX =function () &#123;console.log(this.x);&#125;;function Children()&#123; var temp=new Parent(); //temp就是Parent的一个实例:x、writeX、getX for(var key in temp)&#123; this[key]=temp[key]; &#125; temp=null;&#125;var c = newChildren;var d = newChildren;console.log(c.getX ===d.getX); 4)组合式继承（call继承和原型链继承） 原型继承和call继承/冒充对象继承,任意一个组合到一起来实现的,一般来说都是和call继承组合 缺点： 组合式继承 1.子类会把父类的实例属性（私有属性），继承过来两份 一份存储在子类实例对象本身，另一份存储在原型链上 b insaceof A =&gt;TRUE 只要能在原型链上查找到，那么返回的就是ture 调用了两次父类，产生两个作用域，消耗浏览器内存123456789101112function Parent() &#123; this.x = 100; this.writeX = function () &#123;&#125;&#125;Parent.prototype.getX =function () &#123; console.log(this.x);&#125;;function Children()&#123; Parent.call(this);&#125;Children.prototype = newParent;var c = newChildren; 5)原型式继承 只能继承父类的公有方法,通过Object.create()方法 create : 首先创建一个新对象，并且把第一个参数 作为 这个新对象的原型 IE低版本浏览器不支持这种ES5方法1234function A ()&#123;&#125;B.prototype = Object.create(A.prototype)//=&gt; B.prototype.__proto__ === A.prototypeB.prototype = Object.create(null) //=&gt; &#123;&#125;function B ()&#123;&#125; 6)寄生组合式继承(最理想的继承方法)123456789function A ()&#123; this.title = 'xxx' &#125; B.prototype = Object.create(A.prototype)//=&gt;原型式继承 只负责继承父类的公有属性 function B ()&#123; if(this instanceof B)&#123; A.call(this)//=&gt;call继承 只负责继承父类的私有属性 &#125; &#125; 7)ES6中的继承 1.ES6中创建类是由自己标准语法的，这种语法创建出来的类，只能new执行，不能当做普通函数执行 1234567891011class Fn &#123; //=&gt;Fn是类名，没有小括号 constructor (n,m) &#123; //=&gt;等价于传统ES5类的构造体 this.x = n this.y = m &#125; getX () &#123;...&#125;//=&gt;给Fn的原型上设置方法（只能设置方法，不能设置属性） static AA（）｛...｝//=&gt;把Fn当做一个普通对象，添加私有属性（和实例没有关系，同样也只能设置方法）&#125;let f = new Fn (10,20)console.log(f.x,f.y)//=&gt; (10,20) 2.ES6中类的继承 这种方法保留了子类B的constructor属性 123456789101112131415class A &#123; constructor(n)&#123; console.log(n)//=&gt;100 this.x = 100 &#125;console.log(n)//=&gt;100console.log(n)// getX()&#123;console.log(this.x)&#125;&#125;class B extends A&#123;//=&gt;extends类似于实现了原型继承 constructor()&#123; super(100)//=&gt;类似于call继承，在这里super相当于把A的constructor给执行了，并且让方法中的this是B的实例 this.y = 200 &#125; getY()&#123;console.log(this.y)&#125;&#125;let f = new B()]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流和防抖]]></title>
    <url>%2F2017%2F03%2F12%2FJS%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[函数节流和防抖 函数节流的原理 函数节流的原理挺简单的，估计大家都想到了，那就是定时器。当我触发一个时间时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。 代码实现12345678910function throttle(method, context) &#123; clearTimeout(methor.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;， 100); &#125; 调用：window.onresize = function()&#123; throttle(myFunc); &#125;这样两次函数调用之间至少间隔100ms impress下的节流函数封装 123456789101112var throttle = function(fn, delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125;; &#125;; 使用闭包的方法形成一个不销毁的栈内存，存放定时器变量timer 调用：window.onresize = throttle(myFunction,100) 深化函数节流 函数节流让一个函数只有在你不断触发后停下来歇会才开始执行，中间你操作得太快它直接无视你。这样做就有点太绝了。resize一般还好，但假如你写一个拖拽元素位置的程序，然后直接使用函数节流，那恭喜你，你会发现你拖动时元素是不动的，你拖完了，它直接闪到终点去。1234567891011121314151617181920var throttleV2 = function(fn, delay, mustRunDelay)&#123; var timer = null; var t_start; return function()&#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start)&#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay)&#123; fn.apply(context, args); t_start = t_curr; &#125; else &#123; timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125; &#125;; &#125;; 简单来说，函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉。1234567891011function throttle(fn, interval = 300) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 函数防抖 其实函数防抖的原理也非常地简单，通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了。123456789function debounce(fn, interval = 300) &#123; let timeout = null; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125; 总结其实函数节流与函数防抖的原理非常简单，巧妙地使用 setTimeout 来存放待执行的函数，这样可以很方便的利用 clearTimeout 在合适的时机来清除待执行的函数。 使用函数节流与函数防抖的目的，在开头的栗子中应该也能看得出来，就是为了节约计算机资源。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>函数防抖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS盒子模型]]></title>
    <url>%2F2017%2F01%2F12%2FJS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JS盒子模型 css 盒子模型 : width height border padding margin js 盒子模型 : client offset scroll client clientWidth: 盒子的文本宽度width，+ 左右padding （正常的盒子模型，当在怪异盒模型中clientWidth不能使用这个公式，我们可以理解为盒子的可视区域的宽度） clientHeight: 盒子的文本高度height，+ 上下padding clientLeft: 盒子的左border clientTop: 盒子的上border 内容溢出对client没有任何影响 offset offsetParent: 上级参照物 有定位的父级盒子 offsetWidth: 盒子文本width + 左右padding + 左右border === clientWidth + 左右border ，跟内容溢出没有关系 offsetLeft : 盒子的外边框 到 上级参照物 内边框 的距离 scroll scrollHeight 若内容没有溢出时，跟clientHeight一样 若内容溢出时，当元素增加 overflow-hidden 属性的话，那么scrollHeight的值：内容 + 上下padding；没有overflow-hidden的属性的话，内容 + 上padding-scrollTop 滚动条卷去的内容的高度-scrollLeft 滚动条卷去的内容的宽度 1）以上13个属性中，只有scrollTop和scrollLeft 可以设置的属性，其他都是只读属性2）获取一屏幕的高度： document.documentElement.clientHeight || document.body.clientHeight 对其他浏览器的兼容问题3）获取整个文档的高度：document.documentElement.scrollHeight || document.body.scrollHeight4）监听浏览器窗口发生的事件： window.onresize = function (){…}5）当遇到&lt;table&gt;&lt;/table&gt;标签时，td 和 th 父级盒子都是table，不再是body6）改变盒子的css中样式left、transform等属性改变盒子的位置，不会改变offsetLeft的值；只有改变盒子的width margin padding 值的时候，盒子的offsetLeft值才会发生改变 123456789101112131415function offset (ele)&#123; let left = ele.offsetLeft, top = ele.offsetTop, parent = ele.offsetParent while(parent &amp;&amp; parent.nodeName.toUpperCase() != 'BODY')&#123; //代码从左向右读取，先判断parent存不存在，在判断parent是否为body left += parent.clientleft + parent.offsetLeft top += parent.clientTop + parent.offsetTop parent = parent.offsetParent &#125; return &#123; left, top&#125; &#125; console.log(offset(inner)) 简单的文字循环上下移动,利用setTimeout实现123456789var timer = null, maxH = box.scrollHeight - box.clientHeight function run ()&#123; clearTimeout(timer)//清除定时器 box.scrollTop++ (box.scrollTop + 20) &gt;= maxH ? box.scrollTop = 0 : null timer = setTimeout(run,10) &#125; run() 简单的文字循环上下移动,利用setInterval实现1234var timer = setInterval(()=&gt;&#123; box.scrollTop++ (box.scrollTop + 20) &gt;= (box.scrollHeight - box.clientHeight) ? box.scrollTop = 0 : null &#125;,10) 跑马灯案例，通过改变scrollLeft值改变1234567891011121314let ul = document.querySelector('ul'), box = document.querySelector('.box') //maxL = box.scrollWidth - box.clientWidth //=&gt;理论上是800 // console.log(maxL) 但是这里输出的是0 //这是因为加载img图片是异步事件，是等页面的代码执行完成后 //再通过图片路径，，加载图片，所以输出为0 ul.innerHTML += ul.innerHTML ul.style.width = '1600px' var timer = setInterval(()=&gt;&#123; box.scrollLeft++ box.scrollLeft &gt;= 800 ? box.scrollLeft = 0 :null &#125;,10) //另外一种跑马灯思路：通过改变ul的C3的left值，使图片移动 //能够实现一样的效果，但是这样做会引发多次的DOM回流，降低浏览器性能]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>盒子模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux]]></title>
    <url>%2F2016%2F04%2F09%2FRedux%2F</url>
    <content type="text"><![CDATA[Redux介绍及核心API是由: reducer + flux 两个辅助框架结合而成; createStore : 创建一个store数据管理库; store.dispatch : 通知store,根据指令,改变数据; store.getState : 获取store中的数据; store.subscribe : 函数订阅store中的数据,当数据发生改变时,触发函数执行,更新数据; 如何在React工程项目中使用Redux 在src目录下,创建一个新的目录store; ,在store下创建index.js文件,执行以下代码:12345678910import &#123;createStore&#125; from 'redux';import reducer from './reducer.js';const store = createStore( reducer, // 设置本地redux调试工具 window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__() )export default store ; 3.在store目录下,新建一个文件reducer.js,执行以下代码:123456789101112131415161718192021222324252627282930313233import &#123; CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM&#125; from './actionType.js';const defaultState = &#123; inputValue:'123', list:[1,2,3]&#125;// 可以接受state,但是绝不能改变state数据// 定义一个常量赋值state,然后对这个常量进行改变;export default (state = defaultState,action) =&gt; &#123; // console.log(state,action) if(action.type === CHANGE_INPUT_VALUE)&#123; // 深层拷贝state const newState = JSON.parse(JSON.stringify(state)) newState.inputValue = action.value return newState &#125; if(action.type === ADD_TODO_ITEM)&#123; const newState = JSON.parse(JSON.stringify(state)) newState.list.push(newState.inputValue) newState.inputValue = '' return newState &#125; if(action.type === DELETE_TODO_ITEM)&#123; const newState = JSON.parse(JSON.stringify(state)) newState.list.splice(action.index,1) return newState &#125; return state&#125; 在store文件目录下,新建actionCreator.js文件,写入代码:为方便代码测试,以及代码的可读性和维护性1234567891011121314151617import &#123; CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM&#125; from './actionType.js';export const getInputChangeAction = (value)=&gt;(&#123; type:CHANGE_INPUT_VALUE, value&#125;)export const getAddItemAction = ()=&gt;(&#123; type:ADD_TODO_ITEM&#125;)export const getDeleteItemAction = (index)=&gt;(&#123; type:DELETE_TODO_ITEM, index&#125;) Redux需注意的问题点 store只有唯一一个; 只有store才能改变自己的数据,reducer只是定义常量接收,待数据改变后,返回store一个新数据; reducer模块返回一个纯函数; 纯函数:给定固定的输入,就一定会有固定的输出,且没有其他副作用; 中间件redux-thunk 及设置redux本地数据调试工具定义:中间件可以理解为对store中的dispatch方法重新封装升级,没引用中间件,dispacth只能将action对象传递给store引用中间件后,action可以定义为函数,dispatch会将action的函数执行,并将自己作为实参传入; 安装: npm install redux-thunk --save 在store目录下配置12345678910111213141516171819import &#123;createStore,applyMiddleware,compose&#125; from 'redux';import reducer from './reducer.js';import thunk from 'redux-thunk';// 设置本地redux调试工具const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123; &#125;) : compose;const enhancer = composeEnhancers( applyMiddleware(thunk) // other store enhancers if any);const store = createStore( reducer, enhancer)export default store ; 中间件 saga 的使用方法 在store数据库中使用saga中间件 12345678// 导入saga包import createSagaMiddleware from 'redux-saga';// 导入本地的saga函数模块,异步操作主要发生这个自定义的模块内import todoSaga from './sagas.js';// 定义一个使用saga中间件的函数const sagaMiddleware = createSagaMiddleware();// run API 导入这个自定义的函数（异步请求数据）sagaMiddleware.run(todoSaga); demo : todoSaga.js文件 123456789101112131415161718192021222324function* getInitList ()&#123; try &#123; const res = yield axios.get('pathname') const action = getListAction(res.data); yield put(action) &#125;catch(e)&#123; console.log('数据请求失败') &#125;&#125;// async function getInitList()&#123;// try&#123;// const res = await axios.get('pathname')// const action = getListAction(res.data)// await put(action)// &#125;catch(e)&#123;// console.log('数据请求失败')// &#125;// &#125;generator函数 配合yield指令,执行takeEvery会捕捉到dispatch派发的action,并执行后面对应的函数function* todoSaga() &#123; yield takeEvery(GET_INIT_LIST, getInitList);&#125;export default todoSaga;]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>store 纯函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React进阶]]></title>
    <url>%2F2016%2F03%2F29%2FReact%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[React框架性能优化的几个点 子组件shouldComponentUpdate 判断后才返回false/ture 避免组件的重复无用的渲染; 把改变this指向的函数作用域绑定,放到constructor中定义,避免重复绑定; setState方法,将连续多次的数据更新,放到一次执行,降低比对频率,来更新视图; 使用虚拟DOM,极大的提升性能;1.虚拟DOM如何提升性能 原生思路实现视图更新 定义state数据; JSX模板; 数据 + 模板 结合,生成真实的DOM,来显示; state发生变化; 数据 + 模板 结合, 生成真实的DOM,替换原来的DOM; 缺陷: 两次生成了真实的DOM,并用新DOM替换旧DOM,非常的耗性能; JQuery实现视图更新 定义state数据; JSX模板; 数据 + 模板 结合,生成真实的DOM,来显示; state数据发生改变; 数据 + 模板 结合,生成真实的DOM,并不直接替换原始的DOM; 新的DOM(DocumentFragment 文档碎片)和原始的DOM 作比对, 找差异 找出input框发生了变化; 只用新的DOM中新的input框元素,替换掉老的DOM中的input元素; 缺陷 : 性能的提升并不明显 React虚拟DOM实现视图更新 定义state数据; JSX模板; 生成虚拟DOM(虚拟DOM就是一个JS对象,用它来描述真实的DOM),极大的提升性能;[&#39;div&#39;,{id:&#39;abc&#39;},{&#39;span&#39;,{},&#39;hello world&#39;}] 数据 + 模板 结合,生成真实的DOM,来显示; &lt;div id = &#39;abc&#39;&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt; state数据发生变化; 生成新的虚拟DOM;[&#39;div&#39;,{id:&#39;abc&#39;},{&#39;span&#39;,{},&#39;bye bye&#39;}] 比较原始虚拟DOM和新的虚拟DOM,找到区别是span中内容,极大的提升性能; 直接操作DOM,改变span中内容;注意: JS生成一个真实的DOM节点比生成一个虚拟DOM,性能要消耗特别多, 因为生成真实DOM需要调用高级API; JSX语法,经过babel转译成React识别的语言, 经过React中的createElement生成虚拟DOM(JS对象),并做比较 实现API:createElement 和 createTextNode 最后通过React中的方法,将虚拟DOM节点插入到root容器的根节点中,渲染在页面上;3.虚拟DOM使得跨端应用得以实现,React Native,不仅能开发网页应用,也能开发原生应用 React中的DOM Diff算法同层比对:同一层级有difference,那么这个层级下面的所有dom结构都要替换这种比较方法比较快虚拟DOM的key值,作比较 生命周期函数定义:在某一个函数组件会自动执行的函数 initialization阶段 constructor : 初始化 props and states Mounting(除render函数外,其他3个只执行一次) componentWillMount : 组件被挂载之前,自动执行 render componentDidMount : 组件被挂载页面后,自动执行 Updation(只要数据发生改变,函数就会重复执行) shouldComponentUpdate : 返回值 false / true 根据返回值的不同,react会选择性的更新视图 componentWillUpdate render componentDidUpdate 当存在子组件的情况下 componentShouldReciveProps(nextProps,nextState)一个组件从父组件接收参数如果这个组件第一次出现在父组件中,这个周期函数将不会执行如果这个组件已经出现在父组件中,只要父组件的render函数重新执行,那么子组件的这个函数会再次执行; Unmounting componentWillUnmount : 组件被移除之前执行; 在react中,我们通常使用三元运算,进行子组件的加载和隐藏;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>虚拟DOM Diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础入门]]></title>
    <url>%2F2016%2F03%2F27%2FReact%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[参考Blog阮一峰React入门实例教程阮一峰Redux基础入门 关于React引发的思考 声名式开发; 组件化开发; 可以与其他框架并存; 函数式变成,便于前端的自动化测设; 单向数据流 父组件向子组件传递的数据具有只读行; 视图层框架 结合其他框架工具 Flux和redux等工具管理数据; 使用react脚手架工具快速创建一个项目 在目录下打开cmd命令行工具; 运行npx create-react-app my-app命令，快速创建一个项目(npm的版本需在5.2.0+); 运行yarn start命令，启动项目，并在localhost:3000端口自动打开项目; 项目成功运行在浏览器客户端，证明react脚手架成功搭建; JSX语法定义：通过在js文件引入react的包,可以直接写入html5标签元素,我们称之为jsx语法;知识点：1.ReactDOM内置组件是用来处理jsx语法;2.通常定义组件名时,我们需要大写首字母,但是对于一般的H5标签,我们需要小写,用来区分组件和h5标签;3.render函数的返回值,即组件html部分,有且只有一个根元素标签;4.通常我们引入Fragment占位符,将html部分进行包裹;6.通常定义组件名时,我们需要大写首字母,但是对于一般的H5标签,我们需要小写,用来区分组件和h5标签;7.JSX使用{}进行包裹,内部可以写变量,三元表达式,也可以放入函数执行的结果;8.{}内部不可以写对象或函数,但是可以显示对象里定义的key-value键值对;9.行内属性style后面必须是一个对象,使用toString方法进行转译;10.react区别于vue框架,是一种单向数据流,只能数据驱动视图;12345678910111213141516171819import React,&#123;Component,Fragment&#125; from 'react';import ReactDOM from 'react-dom';class App extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;hello world&lt;/h2&gt; &lt;/div&gt; ); &#125;;&#125;;ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); render渲染函数ReactDOM.render(jsx结构,container,callback()); 第一个参数: 当前操作的dom结构 第二个参数: 目标容器 第三个参数: 回调函数,会在dom放入容器之后，触发 createElement函数封装目的: ele 和 nEle 等价1234567891011let ele = React.createElement( 'h1', &#123;id:'qqq',className:'www'&#125;, '哈哈哈', React.createElement('div',null,'呵呵呵'))let ele1 = &lt;h1 id='qqq' className='www'&gt; 哈哈哈 &lt;div&gt;呵呵呵&lt;/div&gt; &lt;/h1&gt; 代码实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let fn = function (str)&#123; return str.replace(/[A-Z]/g,function(n)&#123; return '-' + n.toLowerCase() &#125;)&#125;class Element &#123;constructor(type,attr,children)&#123; this.type = type this.attr = attr this.children = children&#125;render()&#123;let ele = document.createElement(this.type)for(let key in this.attr)&#123;switch(key)&#123; case 'htmlFor': ele.setAttribute('for',this.attr[key]); break; case 'className': ele.setAttribute('class',this.attr[key]); break; case 'style': let str = '' let obj = this.attr[key]; for(let key in obj)&#123; str += `$&#123;fn(key)&#125;:$&#123;obj[key]&#125;;` &#125; str = str.slice(0,str.length-1); ele.setAttribute('style',str) break; default: ele.setAttribute(key,this.attr[key]) break; &#125;&#125;this.children.forEach(item =&gt; &#123;let nEle = item instanceof Element ? item.render():document.createTextNode(item)ele.app,endChild(nEle)nEle = null;&#125;);return ele&#125;&#125;let react = &#123; createElement(type,attr,...children)&#123; return new Element(type,attr,children) &#125;&#125;;let reactDOM = &#123; render(ele,container)&#123; container.appendChild(ele.render()) &#125;&#125;; 定义组件定义: 创建一个App类，并继承react中component类的属性，这时候我们就创建一个App的组件; 无状态组件 : 没有state属性,通过props属性取得数据; 使用函数定义组件=构造函数 1234567891011function Person(props)&#123; let &#123;id,className&#125; = props return( &lt;div id = &#123;id&#125; className = &#123;className&#125;&gt; hello world &lt;/div&gt; )&#125;ReactDOM.render(&lt;div&gt; &lt;Person id = "qqq" className = 'www'&gt;&lt;/Person&gt;&lt;/div&gt;,document.getElementById('root')) 使用class语法: 1234567891011121314class Person extends Component &#123; constructor(props)&#123; super(props) this.state = &#123; &#125; &#125; render()&#123; &#125;&#125;ReactDOM.render(&lt;div&gt; &lt;Person id = "qqq" className = 'www'&gt;&lt;/Person&gt;&lt;/div&gt;,document.getElementById('root')) 组件间的通讯知识点: react组件中的数据来源 一个是属性(props),一个是状态(state), 但是不能直接修改props中的数据,而state中的数据可以修改,但是需要用setState触发render函数; 在原生标签上,不能有对象的数据格式; 自定义组件,行内属性的值 类型不限, 可以是对象; 父组件通过行内属性向内属性向子组件传递数据;将属性包裹成一个对象,向子组件的constructor函数传递实参 子组件通过this.props拿到父组件的数据; 父组件通过自定义属性传递一个函数体,子组件通过this.props.xxx(参数), 通过让函数体执行，结合传参数的方式修改父组件数据; setState函数,能触发render函数重新执行,合并渲染虚拟DOM,在Component的原型上; &lt;button onClick = {this.props.add2.bind(1111,this.state.str2)}&gt;按钮2&lt;/button&gt; 若方法是父组件中定义,那么子组件在调用时,不用在意this的指向问题,只要执行即可 因为方法是在父组件中执行的时候,this已经被规定指向父组件; 事件 对应的事件对象,只能在函数执行的过程中可以获取; 事件执行完毕后就不能再获取到,React会把它设置成null,节省性能; 阻止默认事件 原生JS可以使用 e.preventDefault() 或者 e.returnValue = false(IE的方式); 在React中,只能使用e.preventDefault(); 若bind后面除this外,有其他参数,则会将默认的事件对象当成最后一个参数,传参到add函数中; 改变组件原型函数执行时this指向的三种方法,以下代码为实现方式; 12345678add(n,e)&#123; console.log(n,e)&#125;1)add = (n,e)=&gt;&#123; console.log(n,e)&#125;&lt;div 2)onClick = &#123;this.add.bind(this,2)&#125;&gt;&lt;/div&gt;&lt;div 3)onClick = &#123;(e)=&gt;&#123;this.add(e)&#125;&#125;&gt;&lt;/div&gt; children类似于Vue中的插槽slot用法:代码实现如下用途: 使用该组件的人,可以通过children属性,渲染出组件标签类名内部包裹的内容123456789101112render()&#123;console.log(this.props.children)return(&lt;div className=''&gt;&#123;this.props.children[3] || 'hahaha'&#125;&lt;/div&gt;)&#125; ReactDOM.render(&lt;App id = '111'&gt; "我是你爸爸" &lt;div&gt;hello&lt;/div&gt; &lt;h1&gt;world&lt;/h1&gt;&lt;/App&gt;,window.root)]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React Jsx render Redux</tag>
      </tags>
  </entry>
</search>
