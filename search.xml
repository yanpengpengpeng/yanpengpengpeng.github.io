<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TS初始化语法]]></title>
    <url>%2F2018%2F07%2F04%2FTS%E8%AF%AD%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[TS语法初始化一个项目 1.初始化项目：进入你的编程文件夹后，可以使用npm init -y来初始化项目，生成package.json文件。 2.创建tsconfig.json文件，在终端中输入tsc –init：它是一个TypeScript项目的配置文件，可以通过读取它来设置TypeScript编译器的编译参数。 3.安装@types/node,使用npm install @types/node –dev-save进行安装。这个主要是解决模块的声明文件问题。 4.编写HelloWorld.ts文件，然后进行保存，代码如下。12var a:string = "HelloWorld"console.log(a) 5.在Vscode的任务菜单下，打开Terminal下的Run Build Task，然后选择tsc：build-tsconfig.json，这时候就会生成一个helloWorld.js文件123"use strict";var a = 'helloworld';console.log(a); 6.在终端中输入node helloWorld.js就可以看到结果了。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-components]]></title>
    <url>%2F2018%2F04%2F02%2FVue-components%2F</url>
    <content type="text"><![CDATA[组件 - components 定义: 组件的出现，就是为了拆分vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可; 组件化和模块化的区别 模块化:是从代码逻辑的角度进行划分的,方便代码分层开发,保证每个功能模块的只能单一。 组件化:是从UI界面的角度进行划分的，前端的组件化，方便UI组件的重用。 创建组件的方式第一种 1.1 123let com1 = Vue.extend(&#123; template:"&lt;h3&gt;这是使用Vue.extend创建出来的组件&lt;/h3&gt;"&#125;) 1.2Vue.component(“mycom1”,com1) 引入的时候,使用标签进行渲染可以合并成一步: 123Vue.component('mycom1',Vue.extend(&#123; template:"&lt;h3&gt;这是使用Vue.extend创建出来的组件&lt;/h3&gt;"&#125;)) 第二种12345注意:无论是哪种方式创建出来的组件，组件的template属性指向的内容， 必须有且只有唯一的一个根元素 Vue.component('mycom2',&#123; template:'&lt;div&gt;&lt;h3&gt;这是使用Vue.extend创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;' &#125;) 第三种Vue.component(‘mycom2’,{template:’#temp1’}) 在APP控制的区域外，定义一个ID为temp1的template标签，在标签元素节点可以写你想要的代码 组件中的data123456789101112131415161718192021注意：data必须是一个函数，而且函数必须返回一个对象， 模板中的元素行内指令可以调用，这里返回对象的意义， 当调用多次同一个组件的时候，虽然返回对象内容相同， 但是是引用数据类型，空间地址不一样， 组件之间的数据完全独立，不会因为其他组件数据的变化而变化let vm2 = new Vue(&#123; el:'#app2', data:&#123; &#125;, components:&#123; login:&#123; template:'#temp1', data:function()&#123; return&#123; msg:'' &#125; &#125; &#125; &#125; &#125;) Vue提供的4个标签属性 transitiontransition-grouptemplatecomponent 子父组件 如何相互传值1&lt;com1 :parentmsg = "msg" @parentfuc123 = "fn"&gt;&lt;/com1&gt; 父组件通过绑定自定义属性，向子组件内传入data数据父组件通过绑定自定义事件，向子组件内传入methods方法props:[‘parentmsg’] this.$emit(fn,this.msg)子组件通过props:[‘自定义属性名-parentmsg’]，接收父组件传进的data数据子组件通过调用$emit(‘自定义方法名-parentfuc123’，第一参数,第二参数…)方法，接收父组件方法，并通过第一参数，第二参数…，同时向父组件内传值]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router]]></title>
    <url>%2F2018%2F03%2F29%2FVue-router%2F</url>
    <content type="text"><![CDATA[路由 v-router前端路由和后端路由的区别 后端路由:对于普通网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源 前端路由:对于单页面应用程序(SPA)来说，主要是通过URL中的hash值来实现不同页面之间的切换；同时，hash有一个特点:HTTP请求中不包括hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现 在单页面应用程序中，这种通过hash改变切换页面的方式，称作前端路由（区别于后端路由） 创建一个路由对象及语法规则（不适用于webpack）123456789101112131415161718192021&lt;script src = 'https://unpkg.com/vue-router@2.0.0/dist/vue-router.js'&gt;&lt;/script&gt; //第一步安装路由，要在vue.js之后 // 引入后，在window全局对象中，就有了一个路由的构造函数，叫做VueRouter let routerObj = new VueRouter(&#123; routes:[ // =&gt; 路由匹配的规则 &#123;path:'/login',component:login&#125;, &#123;path:'/',redirect:'/login'&#125; //=&gt; 重定向，强制页面默认在login页面上 // =&gt; 1.每个路由规则都是一个对象，这个队则身上必须有两个属性 // =&gt; 2.属性1: 是path，表示监听这个路由地址 // =&gt; 3.属性2: 是component，表示前面匹配是path， 则展示对应的component对应的组件 // =&gt; 注意: component的属性值必须是一个模板对象,不能是组件名称 ] &#125;) 通过：router:routerObj 将路由对象挂载到实例上 通过：router-view 将符合path的组件展示在页面上，若出现多个view，则会重复展示符合条件的组件 通过：&lt;router-link to = "/login"&gt;登录&lt;/router-link&gt; &lt;router-link to = "/resister"&gt;注册&lt;/router-link&gt; router-link 相当于a标签，点击，跳转到指定的hash值 路由传参的两种方式 ‘?’ 传参，通过this.$route.query.id 获取 1234 &lt;router-link to = &quot;/login?id=10&amp;name=zs&quot;&gt;登录&lt;/router-link&gt;&#123;path:&apos;/login&apos;,component:login&#125;console.log(this.$route.query.id)通过路径?传参方式传入的值，通过query获取 在模板中通过:id /: name 先进行占位，然后在vm的实例中进行设置，最后可通过params获取 123&lt;router-link to = &quot;/register/id=20/name=wl&quot;&gt;注册&lt;/router-link&gt;&#123;path:&apos;/register/:id/:name&apos;,component:register&#125;console.log(this.$route.params.id) 注意原理: 1)当我们通过传参时，vue都会通过设置的path，解析出一个正则regexp,去匹配fullpath 2)当fullpath是?传参时，匹配失败，params为空，但是可以通过query获取 3)当我们通过设置path占位符时，捕捉到fullpath，可以通过params获取 路由的嵌套 使用children属性，实现子路由，同时，子路由的path前面，不要带’/‘,否则以根路径开始请求，这样不方便客户理解URL路径123456789101112let router = new VueRouter(&#123; routes: [ &#123; path:'/account', component:account, children:[ &#123;path:'login',component:login&#125;, &#123;path:'register',component:register&#125; ] &#125; ] &#125;) 命名视图的用法1&lt;router-view name = "left"&gt;&lt;/router-view &gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-transition]]></title>
    <url>%2F2018%2F03%2F29%2FVue-transition%2F</url>
    <content type="text"><![CDATA[Vue动画在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js列表动画效果 transition这个过渡， 内里只能有一个根元素，且只对根元素起作用 duration: 控制Vue设置的类名存在的时间，但是动画效果还是C3设定的时间完成，duration只是延长类名存在时间 li{ background-color: hotpink; transition: all 1s ease; }定义动画开始和结束前的状态.v-enter,.v-leave-to{ transform: translateY(30px); }定义动画开始和结束过程中的状态.v-enter-active,.v-leave-active{ transition: all 0.7s ease; }1.定义元素位置除了display：none外，移动的效果2.move和leave-active 必须结合起来使用3.在结构元素节点上定义 appear 属性 使初始视图具有出场的效果.v-move{ transition: all 0.7s ease; }.v-leave-active{ position: absolute; }]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>transition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-mvvm解析]]></title>
    <url>%2F2018%2F03%2F26%2FVue-mvvm%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Vue.js 的细节 Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节： Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。 Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。 Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。 Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue指令及基础知识]]></title>
    <url>%2F2018%2F03%2F26%2Fvue%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[VUE 数据驱动:操作DOM JS的数据类型 基本 和 引用 改变原数组 —&gt; 数组的变异 pop push shif unshift reverse sort splice(n,m,x,y,z) 不改变原数组 —&gt; slice(n,m) concat indexOf join(‘+’) toString() 数组的迭代方法 forEach map:renturn什么值，就往新数组添加新属性，若没有return值，就添加undefined filter 1)filter的回调函数中return值，若是true，则把当前迭代的项复制一份到新数组arr中 2)filter的返回值是新数组arr some: 1)回调函数中只要有一个回调函数返回的是true，则整个some 返回值就是ture 2)只要某个项满足条件，就不在进行迭代 every: 1)回调函数，每一个都是true，every的返回值才是true 2)换句话说就是只要有一个是false ，整个结果就是false reduce((prev,next)=&gt;):结果就是最后一次迭代的return值 find: 找到满足条件的第一项 includes(item,index)从index索引值开始查找 找到就是true 找不到就是false NODE基础命令 package.json 是项目的依赖表单 dependencies:存储的都是生产环境的依赖 devdependencies:储存的都是开发环境的依赖 scripts:中存储的都是要执行的命令对应的代码 npm run hello : 对应的要执行hello对应的代码 npm i vue –save:在项目中添加依赖，安装依赖 npm i yarn -g : 全局安装yarn，以后可以使用yarn代替npm 去安装一些依赖 VUE - M-V-VM 1.vue 双向数据绑定 ；渐进式；框架 2.视图 V 数据 M VM 3.视图改变 数据自动更新 4.数据更新 视图自动更改 5.渐进式: SPA 单页面开发 核心:vue.js vue-router控制路由 vuex 处理数据 axios 解决请求 声明式 编程式 forEach 声明式 for() 编程式 框架 框架:自己写的代码被框架调用 Vue React Angular BootStrap 库: 自己调用库的代码 Vue的指令 1.v-model: 是vue的指令 name是实例的变量 指令是指让对应的元素做某件事 2.v-text : 展示对应的文本 3.v-once : 对应的标签只渲染一次 1~3指令都是行内属性 4.v-html : 把值中的标签渲染出来 5.v-cloak : 解决渲染闪烁问题[v-cloak] {display: none;} &lt;div v-cloak&gt;{{ message }}&lt;/div&gt; 6.v-show : 控制元素的display:ngone 属性 7.v-on:click : 给元素绑定事件 简写 @click = &#39;fn&#39; 8.v-keyup.enter = ‘fn’ : 给元素绑定键盘事件 9.v-bind:绑定样式 对象 路径 缩写: : 10.v-for : 循环显示元素的,可以循环数组，也可以循环对象、字符串、数字 ，v-for优先级比v-if/else的优先级高，先渲染v-for 11.v-if / v-else-if /v-else :直接不加载元素,先做循环再做判断v-model指令 实现 数据和视图 双向绑定 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt;等表单元素和components组件 单个复选框，绑定到布尔值： 1&lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; CheckBox 多个复选框,绑定到同一个数组：check = [] CSS HTML JS check 若为 [] 一个数组 则3个input框能联系在一起,选择input框，则会在数组中push表单框中的value值 12345radio 单选框 &lt;!-- 多个input绑定同一个变量即可 --&gt; &lt;input type="radio" v-model="fruit" value="1"/&gt;🍎 &lt;input type="radio" v-model="fruit" value="2"/&gt;🍌 &lt;input type="radio" v-model="fruit" value="3"/&gt;🍊 v-model实现数据双向绑定的原理get方法 获取数据，当属性依赖于其他data中属性时，其他数据改变，才会触发这个方法，但必不会触发set方法 最终值是由get方法决定的123456789var obj = &#123;&#125;;Object.defineProperty(obj,'name',&#123; get()&#123;return 123&#125;, set(val)&#123; console.log(val) &#125;&#125;)obj.name = 333;console.log(obj.name) set方法 使用v-model:进行数据的双向绑定 只有点击改变值的时候，才会触发这个方法，触发这个方法必然触发了get方法 修饰符事件修饰符 self: 只有点击元素本身的时候才触发 stop:阻止冒泡 prevent:阻止默认事件 once: 对应的函数只触发一次 capture: 让事件在捕获阶段触发 passive : 优先执行默认事件，在执行绑定的函数，优化移动端性能，只对滚动行为有效v-model修饰符 number : 将字符串转化为数字 类似 parsefloat的效果 trim : 自动去除首尾空格 自定义全局键码Vue.config.keyCodes.f2 = 113 =&gt; 在模板中可以这样使用 `@keyup.f2 = fn’’`· 过滤器1&#123;&#123;money | changeM&#125;&#125; 管道符前边是要处理的数据，后边是处理的参数，最终展示的是函数的返回值 过滤器是可以连续使用的，下一个过滤器的返回值，是上一个过滤器的返回值 全局过滤器和私有过滤器，全局过滤器任何组件都可以调用，私有过滤器只有定义过滤器的组件可以调用 filter 中的方法 可以重名，不会被冲掉，但尽可能不要重名123456Vue.filter('过滤器名称'，function()&#123;&#125;) 全局过滤器 console.log(this) //=&gt; this 指向window在vm实例中定义filters:&#123; '过滤器名称':functon()&#123;&#125;&#125; 私有过滤器 侦听器 Watch 异步用监听,但是比较耗性能，能够深层监听，能够返回oldV 和 newV 两个值供实例调用 深层监听的属性必须是有set和get方法的属性值 计算属性 Computed 同步用计算属性，但依赖性太强，用到get/set方法 定义的方法，挂载在vm的实例，不能跟methods和data重名，但是现在不报错，但是不能用，因为methods中的方法会把computed中的方法冲掉 只要name不发生改变，name2就不发生改变 name2用到谁，就依赖谁123456789101112131415computed:&#123; name2()&#123; return this.name.split('').rerverse().join('') &#125;, name3()&#123; get()&#123; console.log(this.name) return 123 &#125;, set(val)&#123; // 给name3赋值的时候会触发, set函数 // val 是外界 &#125; &#125;&#125; 自定义全局指令 使用directive定义全局的指令 其中参数1：指令的名称，注意，在定义的时候，指令的名称前面，不需要加 -v 前缀 但是在调用的时候，必须在指令名称前加上 v- 前缀 进行调用 参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 12345678910111213 bind:function(el)&#123; =&gt;每当指令绑定到元素身上的时候，会立即执行这个bind函数，只执行一次 //1.注意：在每个函数中，第一个参数永远是el，表示被绑定的那个元素，这个el参数以一个原生JS对象 //2.在元素刚绑定指令的时候，还没有插入到DOM中，这时候，调用focus方法没有起作用 //3.因为，一个元素只有插入到DOM中，才能获取焦点 //el.focus() &#125;, inserted:function(el)&#123; =&gt;表示元素被插入到DOM中的时候，触发这个inserted函数，触发一次 el.focus() &#125;, updated:function(el)&#123; =&gt;每当VNode更新的时候，会执行updated函数，可能会被触发多次 &#125; &#125;) 自定义指令简写:Vue.directive(&#39;focus&#39;,function(el,binding){}) 钩子函数 钩子函数的参数: 指令钩子函数会被传入以下实参 1.el : 指令所绑定的元素，可以用来直接操作 DOM 2.binding: name: 指令名，不包括 v- 前缀; value:指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2; expression:字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 &quot;1 + 1&quot;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的继承方式]]></title>
    <url>%2F2017%2F05%2F12%2FJS%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[类的继承和多态 封装: 把实现一个功能的代码放在一个函数中封装起来，以后再想实现这个功能的时候，我们不需要重新的编写代码了，只需要执行对应的函数即可，我们把这种机制就称之为”函数的封装”–&gt;低耦合高内聚:减少页面中的冗余代码,提高代码的重复使用率12345function fn()&#123; 实现功能的代码&#125; fn(); fn(); 多态:后台语言[java、C#、ASP.net、php…]中的多态：重载、重写重载(Reload)：多个方法,方法名相同,参数的个数或者参数的类型不一样重写(Rewrite)：子类重写父类的方法1)JS中如果函数名相同了,后面的会把前面的函数给覆盖掉,所以JS中不存在重载 fn(); -&gt;2 functionfn(){console.log(1);}2)JS中的多态指的是一个方法的多种形态:一个方法,我们通过传递进来的参数值的不一样,实现不一样的功能根据传递的n和m的值不一样,我们获取的结果也不一样,例如:如果执行的时候不传递任何的参数,返回[0-1)之间的随机小数,如果传递了两个值1/10,返回的是[1-10]之间的随机整数12345678910111213function getRandom(n,m)&#123; n=Number(n); m=Number(m); if(isNaN(n) || isNaN(m))&#123; returnMath.random(); &#125; if(n&gt;m)&#123; n=m+n; m=n-m; n=n-m; &#125; return Math.round(Math.random()*(m-n)+n); &#125; 继承:JS中常用的继承有以下几种方式(子类想要继承父类中的属性和方法)1)原型链继承(我们项目中最常用的一种继承方式)A、子类的原型指向父类的一个实例即可-&gt;原理不是把父类中的方法直接的继承复制过来一份,而是通过原型链的查找机制一级级的向上查找使用的B、原型继承是把父类中私有和公有的属性和方法都当做子类中公有的C、子类可以通过原型链的查找机制把父类原型上的属性和方法进行添加、修改、删除,如果这样操作完成后,我们父类的其他实例都会受到影响-&gt;子类重父类的方法-&gt;类的重写,例如:c.proto.proto.getX=function(){} 相当于子类重写了父类原型上的公有的方法12345function Parent()&#123;this.x = 100;&#125;Parent.prototype.getX =function () &#123;console.log(this.x);&#125;;function Children()&#123;this.x = 200;&#125;Children.prototype = newParent;var c = newChildren; ####2)call继承（借用构造函数继承）A、在子类的函数体中,把父类当做一个普通的函数执行,让父类执行的时候里面的this变为子类的一个实例,这样就相当于直接的给子类的实例增加私有的属性和方法B、call继承只能继承父类私有的属性和方法,而且继承过来后也是子类实例自己私有的C、call继承是直接的把父类中的私有属性和方法相当于克隆一份直接的给子类123456789function Parent()&#123;this.x = 100;this.writeX = function () &#123;&#125;&#125;Parent.prototype.getX =function () &#123;console.log(this.x);&#125;;function Children()&#123; //this-&gt;Children的实例c Parent.call(this);//把Parent当做普通的函数执行,让里面的this变为c-&gt;在执行的时候相当于c.x=100、 c.writeX=function...&#125;var c = newChildren;var d = newChildren;console.log(c.writeX ===d.writeX);//--&gt;false 3)冒充对象继承A、在子类的函数体中,我们创建一个父类的实例,然后把这个实例当做一个普通的对象进行遍历,在每一次遍历的时候,把父类中私有/公有的属性和方法,都当做子类实例的私有属性和方法进行存储(使用 for in 循环可以遍历出类私有属性和自定义的属性方法)B、父类的私有和公有都可以继承,而是是相当于复制了一份继承过来的C、继承过来的都是子类实例私有的属性和方法12345678910111213function Parent()&#123;this.x = 100;this.writeX = function () &#123;&#125;&#125;Parent.prototype.getX =function () &#123;console.log(this.x);&#125;;function Children()&#123; var temp=new Parent(); //temp就是Parent的一个实例:x、writeX、getX for(var key in temp)&#123; this[key]=temp[key]; &#125; temp=null;&#125;var c = newChildren;var d = newChildren;console.log(c.getX ===d.getX); 4)组合式继承（call继承和原型链继承） 原型继承和call继承/冒充对象继承,任意一个组合到一起来实现的,一般来说都是和call继承组合 缺点： 组合式继承 1.子类会把父类的实例属性（私有属性），继承过来两份 一份存储在子类实例对象本身，另一份存储在原型链上 b insaceof A =&gt;TRUE 只要能在原型链上查找到，那么返回的就是ture 调用了两次父类，产生两个作用域，消耗浏览器内存123456789101112function Parent() &#123; this.x = 100; this.writeX = function () &#123;&#125;&#125;Parent.prototype.getX =function () &#123; console.log(this.x);&#125;;function Children()&#123; Parent.call(this);&#125;Children.prototype = newParent;var c = newChildren; 5)原型式继承 只能继承父类的公有方法,通过Object.create()方法 create : 首先创建一个新对象，并且把第一个参数 作为 这个新对象的原型 IE低版本浏览器不支持这种ES5方法1234function A ()&#123;&#125;B.prototype = Object.create(A.prototype)//=&gt; B.prototype.__proto__ === A.prototypeB.prototype = Object.create(null) //=&gt; &#123;&#125;function B ()&#123;&#125; 6)寄生组合式继承(最理想的继承方法)123456789function A ()&#123; this.title = 'xxx' &#125; B.prototype = Object.create(A.prototype)//=&gt;原型式继承 只负责继承父类的公有属性 function B ()&#123; if(this instanceof B)&#123; A.call(this)//=&gt;call继承 只负责继承父类的私有属性 &#125; &#125; 7)ES6中的继承 1.ES6中创建类是由自己标准语法的，这种语法创建出来的类，只能new执行，不能当做普通函数执行 1234567891011class Fn &#123; //=&gt;Fn是类名，没有小括号 constructor (n,m) &#123; //=&gt;等价于传统ES5类的构造体 this.x = n this.y = m &#125; getX () &#123;...&#125;//=&gt;给Fn的原型上设置方法（只能设置方法，不能设置属性） static AA（）｛...｝//=&gt;把Fn当做一个普通对象，添加私有属性（和实例没有关系，同样也只能设置方法）&#125;let f = new Fn (10,20)console.log(f.x,f.y)//=&gt; (10,20) 2.ES6中类的继承 这种方法保留了子类B的constructor属性 123456789101112131415class A &#123; constructor(n)&#123; console.log(n)//=&gt;100 this.x = 100 &#125;console.log(n)//=&gt;100console.log(n)// getX()&#123;console.log(this.x)&#125;&#125;class B extends A&#123;//=&gt;extends类似于实现了原型继承 constructor()&#123; super(100)//=&gt;类似于call继承，在这里super相当于把A的constructor给执行了，并且让方法中的this是B的实例 this.y = 200 &#125; getY()&#123;console.log(this.y)&#125;&#125;let f = new B()]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的事件]]></title>
    <url>%2F2017%2F05%2F12%2FJS%E4%BA%8B%E4%BB%B6%20%E2%80%93DOM0%20%E2%80%93DOM2%E2%80%93%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E2%80%93%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"><![CDATA[事件 –DOM0 –DOM2–发布订阅–拖拽 什么是事件? 指的是是一件事或一个行为 事件 鼠标事件 click 单击 dblclick双击 大约300ms内连续点击两次 mouseover 鼠标滑进 冒泡阶段 先自己触发 后父辈触发 mouseout 鼠标滑出 mouseenter 鼠标移入 捕获阶段 先父辈触发 后自己 mouseleave鼠标移出 mousemove 鼠标滑动（过程） mousedown 鼠标按下（不动） mouseup鼠标抬起 mousewheel鼠标滚轮移动 键盘事件 应用元素：textarea input window html body等都可绑定键盘事件 keydown (键盘按下时触发) keyup（键盘抬起来时触发） keypress（按下时并抬起来时触发，系统键是监听不到的） 系统事件 onload 加载页面资源后 onresize（浏览器窗口发生改变时触发） onscroll（滚动条发生改变时触发） DOMContentLoaded (dom元素加载完了后再触发) 表单元素 onfoucs 获取焦点（光标）时触发 onchange（表单元素发生改变,并且失去焦点后时，才能触发） oninput（移动端，表单输入时触发，只要内容发生改变就会触发） onblur（失去焦点，表示光标离开表单元素时触发） onpropertychange 只要内容发生改变，就会触发 移动端事件 ontouchstart触碰到元素触发 ontouchend离开元素触发 ontouchmove必须在点击的情况，来回移动，才能触发函数 onclick 有大约300ms的延迟 事件绑定：事件行为发生时去做的具体的事情 行为和具体事情要绑定起来这就是事件绑定呀事件对象12345678box.onclick = function(e)&#123;e:事件对象 当执行事件绑定的方法时，浏览器会将事件对象作为实参传递到方法中e.target:事件源 元素对象e.clientX:鼠标点击的位置距离 可视窗口的 左偏移e.clientY:鼠标点击的位置距离 可视窗口的 上偏移e.pageX:鼠标点击的位置距离 BODY的 左偏移e.pageY:鼠标点击的位置距离 BODY的 上偏移&#125; 兼容IE低版本浏览器的写法12345box.onclick = function ()&#123; e = e || window.event var tar = e.target || e.srcElement e.preventDefault ? e.preventDefault():e.returnValue = false 阻止默认行为&#125; 操作这个box上下左右移动 键盘事件1234567891011121314151617enter回车键 ： 13window.onkeydown = function (e)&#123; switch(e.keyCode)&#123;//键盘码 case 37 : box.style.left = parseFloat(box.style.left) - 10 + 'px' break case 38 : box.style.top = parseFloat(box.style.top) - 15 + 'px' break case 39 : box.style.left = parseFloat(box.style.left) + 25 + 'px' break case 40 : box.style.top = parseFloat(box.style.top) + 15 + 'px' break &#125; &#125; 给一个元素（如：div，ul，li）绑定一个行为（如：onclick、onmouseover）等于一个方法 方法里写要执行的东东 默认事件 先执行绑定的事件，再执行默认事件 注：天生自带默认事件的 keydown和input和keyupinput事件是在down之后，up之前触发，阻止默认后，不在触发input； a标签默认进行跳转 锚点定位功能 img绑定鼠标事件后，会触发原生鼠标拖拽事件 移动端默认事件:touchmove 阻止默认事件：document.addEventListener(‘touchmove’,function(){},{passive:false}) （在PC端时需注意，用此方式让绑定的touchmove默认事件 - 即滚动事件 先执行） 12345678910111213141516&lt;div&gt; &lt;img id = 'img' src = 'www.baidu.com'/&gt;&lt;/div&gt;img.onmousemove = function(e)&#123; e.preventDefault() &#125;&lt;a href="https://baidu.com" id="oa"&gt;百度一下&lt;/a&gt; &lt;!-- 正常跳转 --&gt;&lt;a href="javascript:;" id=""&gt;百度两下&lt;/a&gt; &lt;!-- 禁止页面跳转 --&gt;&lt;a href="" id=""&gt;百度三下&lt;/a&gt; &lt;!-- 刷新页面 --&gt;&lt;a href="Javascript :void(0);" id=""&gt;百度四下&lt;/a&gt; &lt;!-- 禁止页面跳转 --&gt;oa.onclick = function (e)&#123;e.preventDefault();alert(111)&#125; 阻止a标签这种默认行为 事件传播 事件冒泡 0级事件是在冒泡阶段触发的 阻止冒泡：e.stopPropagation||e.cancelBubble = true 事件绑定 绑定分为DOM0级事件绑定 和 DOM2级事件绑定 是按照绑定的顺序执行方法 低版本IE浏览器会乱序 DOM0级事件绑定 传统的事件绑定odiv.onclick=function问题 ： DOM0级事件绑定 对同一元素，同一事件绑定多个行为时，后面的行为会覆盖前面的行为，最终只执行最后一次绑定的行为 DOM2级事件绑定 较于0级事件绑定，优点是可以绑定多个方法第一个参数 事件类型第二个参数 事件绑定行为第三个参数 事件传播的方式oiv.addEventListener(“click”,function ( ) {alert(1)},false);true捕获阶段触发 false在冒泡阶段触发 DOM0 和 DOM2 在事件绑定上的区别 1.机制不一样 dom0采用的是给私有属性赋值，所以只能绑定一个方法 dom2采用的是事件池机制，所以能绑定多个不同的方法 2.移除的操作 box.onclick = null dom0移除 dom2 在移除的时候，必须清楚要移除哪一个方法，才能在事件池中移除，所以基于DOM2做事件绑定，我们呢要有“瞻前顾后”的思路，也就是绑定的时候考虑一下如何移除（技巧：不要绑定匿名函数，都绑定实名函数） 3.DOM2事件绑定增加了一些DOM0无法操作的事件行为，例如：DOMContentLoaded事件，（当页面中的HTML结构加载完后才能就会触发执行） IE低版本单独拿出来 IE低版本浏览器绑定方式 IE 6 ~ 8 DOM2级事件绑定odiv.attachEvent(“onclick”,function () {alert(666)})IE 低版本浏览器移除绑定odiv.detachEvent(“onclick”,function () {alert(666)}) DOM事件绑定移除 DOM0级事件移除：odiv.onclick=null DOM2级事件移除 odiv.removeEventListener(“click”,function () {alert(1)},false);移除123/*var odiv=document.getElementById('div1')odiv.onclick=function (e) &#123;&#125;*/ 事件对象 (e)浏览器天生存在的 浏览器记录了事件相关的信息 clientX 到窗口左边的距离 clientY 到窗口上边的距离 pageX 到文档左边的距离 pageY 到文档上边的距离 pageY相当于clientY+(document.documentElement.scrollTop||document.body.scrollTop) type 事件类型 target 事件源 也就是事件绑定的元素 preventDefault 阻止默认行为 IE低版本浏览器 retuenValue=true stopPropagation 阻止冒泡 IE低版本浏览器 cancelBubble=true IE6~8用Window.event 接收事件对象 e = e || Window.event 事件委托 一个容器中，有很多后代元素的点击行为都要处理一些事情，之前的思路是把需要操作的元素一一获取，然后再一一做事件绑定，在不同的方法中完成不同的需求，现在不用了，基于事件的冒泡传播机制，我们可以只给容器的Click绑定一个方法，这样不管以后点击的容器中的哪一个后代元素，都会通过事件的冒泡传播机制，把容器的Click行为触发，把绑定的方法执行，我们在方法执行的时候，根据事件对象中的事件源（e.target）来做不同的业务处理即可，这种机制既是事件委托机制1）容器中很多后代元素的某个行为要进行操作，委托给容器处理是不错的选择2）元素是动态绑定的3）需求是除了xxx，剩下的操作都是干同样的事情业务(此时把点击行为的操作委托给BODY，事件源是xxx做什么，不是同一做什么)……….. 原生拖拽拖放的流程：选中 == &gt; 拖动 == &gt; 释放 选中过程: 在HTML5标准中，为了使元素可拖动，把draggable属性设置为true。文本、图片和链接是默认可以拖放的，它们的draggable属性自动被设置成了true。图片和链接按住鼠标左键选中，就可以拖放。文本只有在被选中的情况下才能拖放。如果显示设置文本的draggable属性为true，按住鼠标左键也可以直接拖放。draggable属性：设置元素是否可拖动。 语法：1234&lt;element draggable="true | false | auto" &gt;true: 可以拖动false: 禁止拖动auto: 跟随浏览器定义是否可以拖动 拖动过程: 每一个可拖动的元素，在拖动过程中，都会经历三个过程，拖动开始 ==&gt;拖动过程中 ==&gt; 拖动结束 dragenter和dragover事件的默认行为是拒绝接受任何被拖放的元素。因此，我们必须阻止浏览器这种默认行为。e.preventDefault() 针对对象 事件名称 说明 被拖动的元素 dragstart 在元素开始被拖动时候触发 drag 在元素被拖动时反复触发 dragend 在拖动操作完成是触发 目的地对象 dragenter 当被拖动元素进入目的地元素所占据的屏幕空间时触发 dragover 当被拖动元素在目的地元素内时触发 dragleave 当被拖动元素没有放下就离开目的地元素时触发 释放过程: 到达目的地之后，释放元素事件 针对对象 事件名称 说明 目的地对象 drop 当被拖动元素在目的地元素里放下是触发，一般需要取消浏览器的默认行为 发布订阅模式（观察者模式） 思想：准备一个容器，把达到指定时间点要处理的事情，事先一一的增加到容器中（发布计划，并且向计划表中订阅方法），当到达指定时间点，通知容器中的方法依次执行即可12345678let $plan = $.Callbacks()// 创建一个空的计划表 空容器 =&gt; $plansetTimeout(function ()&#123; $plan.fire(10,20)//=&gt;fire 就是通知容器中的方法按照顺序依次执行的: 10和20是执行容器中每一个方法的时候，都会给他们出阿迪两个参数值&#125;，1000)$plan.add((x,y)=&gt;&#123;...&#125;)//=&gt;add是向容器中增加方法，remove是从容器中移除方法$plan.add((x,y)=&gt;&#123;...&#125;)$plan.add((x,y)=&gt;&#123;...&#125;) bind源码 利用形成的不销毁的栈内存，用来存值及保护变量不受全局的污染 外层套个函数用来存储我们以后需要的值，return一个匿名函数，编程思想这种编程思想我们称作柯理化函数bianc`Function.prototype.mybind = function mybind (context,…arg){ let _this = this return function anonymous(…innerArg){ _this.apply(obj,arg.concat(innerArg)) } }document.body.onclick = fn.mybind(obj,10,20)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流和防抖]]></title>
    <url>%2F2017%2F03%2F12%2FJS%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[函数节流和防抖 函数节流的原理 函数节流的原理挺简单的，估计大家都想到了，那就是定时器。当我触发一个时间时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。 代码实现12345678910function throttle(method, context) &#123; clearTimeout(methor.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;， 100); &#125; 调用：window.onresize = function()&#123; throttle(myFunc); &#125;这样两次函数调用之间至少间隔100ms impress下的节流函数封装 123456789101112var throttle = function(fn, delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125;; &#125;; 使用闭包的方法形成一个不销毁的栈内存，存放定时器变量timer 调用：window.onresize = throttle(myFunction,100) 深化函数节流 函数节流让一个函数只有在你不断触发后停下来歇会才开始执行，中间你操作得太快它直接无视你。这样做就有点太绝了。resize一般还好，但假如你写一个拖拽元素位置的程序，然后直接使用函数节流，那恭喜你，你会发现你拖动时元素是不动的，你拖完了，它直接闪到终点去。1234567891011121314151617181920var throttleV2 = function(fn, delay, mustRunDelay)&#123; var timer = null; var t_start; return function()&#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start)&#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay)&#123; fn.apply(context, args); t_start = t_curr; &#125; else &#123; timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125; &#125;; &#125;; 简单来说，函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉。1234567891011function throttle(fn, interval = 300) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 函数防抖 其实函数防抖的原理也非常地简单，通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了。123456789function debounce(fn, interval = 300) &#123; let timeout = null; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125; 总结其实函数节流与函数防抖的原理非常简单，巧妙地使用 setTimeout 来存放待执行的函数，这样可以很方便的利用 clearTimeout 在合适的时机来清除待执行的函数。 使用函数节流与函数防抖的目的，在开头的栗子中应该也能看得出来，就是为了节约计算机资源。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>函数防抖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS盒子模型]]></title>
    <url>%2F2017%2F01%2F12%2FJS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JS盒子模型 css 盒子模型 : width height border padding margin js 盒子模型 : client offset scroll client clientWidth: 盒子的文本宽度width，+ 左右padding （正常的盒子模型，当在怪异盒模型中clientWidth不能使用这个公式，我们可以理解为盒子的可视区域的宽度） clientHeight: 盒子的文本高度height，+ 上下padding clientLeft: 盒子的左border clientTop: 盒子的上border 内容溢出对client没有任何影响 offset offsetParent: 上级参照物 有定位的父级盒子 offsetWidth: 盒子文本width + 左右padding + 左右border === clientWidth + 左右border ，跟内容溢出没有关系 offsetLeft : 盒子的外边框 到 上级参照物 内边框 的距离 scroll scrollHeight 若内容没有溢出时，跟clientHeight一样 若内容溢出时，当元素增加 overflow-hidden 属性的话，那么scrollHeight的值：内容 + 上下padding；没有overflow-hidden的属性的话，内容 + 上padding-scrollTop 滚动条卷去的内容的高度-scrollLeft 滚动条卷去的内容的宽度 1）以上13个属性中，只有scrollTop和scrollLeft 可以设置的属性，其他都是只读属性2）获取一屏幕的高度： document.documentElement.clientHeight || document.body.clientHeight 对其他浏览器的兼容问题3）获取整个文档的高度：document.documentElement.scrollHeight || document.body.scrollHeight4）监听浏览器窗口发生的事件： window.onresize = function (){…}5）当遇到&lt;table&gt;&lt;/table&gt;标签时，td 和 th 父级盒子都是table，不再是body6）改变盒子的css中样式left、transform等属性改变盒子的位置，不会改变offsetLeft的值；只有改变盒子的width margin padding 值的时候，盒子的offsetLeft值才会发生改变 123456789101112131415function offset (ele)&#123; let left = ele.offsetLeft, top = ele.offsetTop, parent = ele.offsetParent while(parent &amp;&amp; parent.nodeName.toUpperCase() != 'BODY')&#123; //代码从左向右读取，先判断parent存不存在，在判断parent是否为body left += parent.clientleft + parent.offsetLeft top += parent.clientTop + parent.offsetTop parent = parent.offsetParent &#125; return &#123; left, top&#125; &#125; console.log(offset(inner)) 简单的文字循环上下移动,利用setTimeout实现123456789var timer = null, maxH = box.scrollHeight - box.clientHeight function run ()&#123; clearTimeout(timer)//清除定时器 box.scrollTop++ (box.scrollTop + 20) &gt;= maxH ? box.scrollTop = 0 : null timer = setTimeout(run,10) &#125; run() 简单的文字循环上下移动,利用setInterval实现1234var timer = setInterval(()=&gt;&#123; box.scrollTop++ (box.scrollTop + 20) &gt;= (box.scrollHeight - box.clientHeight) ? box.scrollTop = 0 : null &#125;,10) 跑马灯案例，通过改变scrollLeft值改变1234567891011121314let ul = document.querySelector('ul'), box = document.querySelector('.box') //maxL = box.scrollWidth - box.clientWidth //=&gt;理论上是800 // console.log(maxL) 但是这里输出的是0 //这是因为加载img图片是异步事件，是等页面的代码执行完成后 //再通过图片路径，，加载图片，所以输出为0 ul.innerHTML += ul.innerHTML ul.style.width = '1600px' var timer = setInterval(()=&gt;&#123; box.scrollLeft++ box.scrollLeft &gt;= 800 ? box.scrollLeft = 0 :null &#125;,10) //另外一种跑马灯思路：通过改变ul的C3的left值，使图片移动 //能够实现一样的效果，但是这样做会引发多次的DOM回流，降低浏览器性能]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>盒子模型</tag>
      </tags>
  </entry>
</search>
