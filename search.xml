<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我在荒岛上迎接黎明 - 王小波]]></title>
    <url>%2F2019%2F01%2F01%2F%E7%BE%8E%E6%96%87%2F</url>
    <content type="text"><![CDATA[我在荒岛上迎接黎明 我在荒岛上迎接黎明。太阳初升时，忽然有十万支金喇叭齐鸣。阳光穿过透明的空气，在暗蓝色的天空飞过。在黑暗尚未褪去的海面上燃烧着十万支蜡烛。我听见天地之间钟声响了，然后十万支金喇叭又一次齐鸣。我忽然泪如雨下，但是我心底在欢歌。有一柄有弹性的长剑从我胸中穿过，带来了剧痛似的巨大快感。这是我一生最美好的时刻，我站在那一个门坎上，从此我将和永恒连结在一起……因为确确实实地知道我已经胜利，所以那些燃烧的字句就在我眼前出现，在我耳中轰鸣。这是一首胜利之歌，音韵铿锵，有如一支乐曲。我摸着水湿过的衣袋，找到了人家送我划玻璃的那片硬质合金。于是我用有力的笔迹把我的诗刻在石壁上，这是我的胜利纪念碑。在这孤零零的石岛上到处是风化石，只有这一片坚硬而光滑的石壁。我用我的诗把它刻满，又把字迹加深，为了使它在这人迹罕至的地方永久存在。 在我小的时候，常有一种冰凉的恐怖使我从睡梦中惊醒，我久久地凝视着黑夜。我不明白我为什么会死。到我死时，一切感觉都会停止，我会消失在一片混沌之中。我害怕毫无感觉，宁愿有一种感觉长久存在。哪怕它是疼。 长大了一点的时候，我开始苦苦思索。我知道宇宙和永恒是无限的，而我自己和一切人一样都是有限的。我非常非常不喜欢这个对比，老想把它否定掉。于是我开始思考是否有一种比人和人类更伟大的意义。想明白了从人的角度看来这种意义是不存在的以后，我面前就出现了一片寂寞的大海。人们所做的一切不过是些死前的游戏…… 在冥想之中长大了以后，我开始喜欢诗。我读过很多诗，其中有一些是真正的好诗。好诗描述过的事情各不相同，韵律也变化无常，但是都有一点相同的东西。它有一种水晶般的光辉，好象是来自星星……真希望能永远读下去，打破这个寂寞的大海。我希望自己能写这样的诗。我希望自己也是一颗星星。如果我会发光，就不必害怕黑暗。如果我自己是那么美好，那么一切恐惧就可以烟消云散。于是我开始存下了一点希望——如果我能做到，那么我就战胜了寂寞的命运。 但是我好久好久没有动笔写，我不敢拿那么重大的希望去冒险。如果我写出来糟不可言，那么一切都完了。 我十七岁到南方去插队。旱季里，那儿的天空是蓝湛湛的，站在小竹楼里往四下看，四处的竹林翠绿而又苗条。天上的云彩又洁白又丰腴，缓缓地浮过。我觉得应该试一试。 开始时候象初恋一样神秘，我想避开别人来试试自己。午夜时分，我从床上溜下来，听着别人的鼻息，悄悄地走到窗前去，在皎洁的月光下坐着想。似乎有一些感受、一些模糊不清的字句，不知写下来是什么样的。在月光下，我用自来水笔在一面镜子上写。写出的字句幼稚得可怕。我涂了又写，写了又涂，直到把镜子涂成暗蓝色，把手指和手掌全涂成蓝色才罢手。回到床上，我哭了。这好象是一个更可怕的噩梦。 后来我在痛苦中写下去，写了很久很久，我的本子上出现很多歪诗、臭诗，这很能刺激我写下去。到写满了三十个笔记本时，我得了一场大病，出院以后瘦得象一只瘦猫。正午时分，我蹲下又站起来，四周的一切就变成绿色的。 我病退回北京，住在街道上借来的一间小屋里。在北京能借到很多书，我读了很多文艺理论，从亚里士多德到苏联的比西莫夫，试着从理性分析中找到一条通向目标的道路，结果一无所成。 那时候我穷得发疯，老盼着在地上拣到钱。我是姑姑养大的，可是她早几年死了。工作迟迟没有着落，又不好意思找同学借钱。我转起各种念头，但是我绝对不能偷。我做不出来。想当临时工，可是户口手续拖着办不完。剩下的只要捡破烂一条路了。 在天黑以后，我拿了一条破麻袋走向垃圾站。我站在垃圾堆上却弯不下腰来。这也许要从小受到熏陶，或者饿得更厉害些。我拎着空麻袋走开时却碰上一位姑娘从这儿走过。我和她只有一面之识，可她却再三盘问我。我编不出谎来，只好照实招了。 她几乎哭了出来，非要到我住的地方看看不可。在那儿，我把我的事情都告诉她了。那一天我很不痛快，就告诉她我准备把一切都放弃。她把我写过的东西看了一遍之后，指出有三首无可挑剔的好诗。她说事情也许不象我想的那么糟糕。但是我无论如何也想不起来那三首诗是怎么写出来的了。我还不是一个源泉，一个发光体，那么什么也安慰不了我。 后来她常到我这儿来。我把我写的都给她看，因为她独具慧眼，很能分出好坏来。她聪明又漂亮。后来我们把这些都放下，开始谈起恋爱来，晚上在路灯的暗影里接吻。过了三个月她要回插队的老家去，我也跟她去了。 在大海边上，有一个小村镇。这儿是公社的所在地，她在公社当广播员，把我安排在公社中学代课。 她有三间大瓦房，盖在村外的小山坡上，背朝着大海，四面不靠人家，连院墙都没有，从陆上吹来的风毫无阻碍地吹着门窗。她很需要有人做伴，于是我也住进那座房子，对外说我是她的表哥，盖这座房子用了我家的钱。人家根本不信，不过也不来管我们的闲事。我们亲密无间，但是没感到有什么必要去登记结婚。我住在东边屋里，晚上常常睡不着觉在门口坐着，她也常来陪我。我们有很多时候来谈论，有很多次谈到我。 看来写诗对我是一个不堪的重负，可是这已经是一件不可更改的事情了。我必须在这条路上走到底。我必须追求这种能力，必须永远努力下去。我的敌手就是我自己，我要他美好到使我满意的程度。她希望我能斗争到底。她喜欢的就是人能做到不可能做到的事情，她的一切希望就系之与于此。如果没有不可能的事情，那么一切都好办了。 我不断地试下去，写过无数的坏诗。偶尔也写过几个美好的句子，但是没有真正使她满意的一篇。我好象老在贫乏的圈子里转来转去，爬不出去。我找过各种各样的客观与主观原因，可是一点帮助也没有。她说我应该从原地朝前跨一步，可是我动弹不得。 我就这么过了好几年。有时挎着她的手到海边去散步时我想：“算了吧！我也算是幸福的了。她是多么好的伴侣。也许满足了就会幸福。”可是我安静不下来。我的脑子总是在想那个渺茫的目标。我常常看到那个寂寞的大海。如果我停下来，那么就是寂寞，不如试下去。 昨天早上，校长让我带十几个学生去赶大潮。我们分两批到大海中间的沙滩上去挖牡蛎，准备拿回去卖给供销社，给学校增加一点收入。下午第一批学生上船以后，忽然起了一阵大风，风是从陆上吹来的。这时潮水已经涨到平了沙滩，浪花逐渐大了起来，把沙洲上的沙子全掀了起来。如果浪把我们打到海里，学生们会淹死，我也可能淹死，淹不死也要进监狱。我让学生们拉住我的裤腰带，推着我与大海对抗。我身高一米九零，体重一百八十斤，如果浪卷不走我，学生们也会安全。 小船来接我们时，浪高得几乎要把我浮起来，一浮起来我们就完了。小船不敢靠近，批在沙滩上搁浅，就绕到下风处，我把学生一个一个从浪峰推出去，让他们漂到船上去。最后一个学生会一点水，我和他一起浮起来时，他一个狗刨动作正刨在我下巴上，打得我晕了几秒钟，醒过来时几乎灌饱了。我再浮上水面，小船已经离得很远。我喊了一声，他们没有听见，我又随浪沉下去。再浮到浪顶时，小船已经摇走，他们一定以为我淹死了。 我在海里挣扎了很久，陆地在天边消失了。我一个劲地往海底沉，因为我比重太大，很不容易浮起来。大海要淹死我。可是我碰上了一条没浆的小船在海上乱漂。我爬上船去，随它漂去。我晕得一塌糊涂，吐了个天翻地覆。天黑以后，风停了。我看见这座大海之中的一个小孤岛，就游了上来。 我在荒岛上迎接黎明，我听到了金喇叭的声音。在这个荒岛上，我写出了一生中第一首从源泉中涌出来的诗，我把它刻在了石头上。 在我的四周都是海，闪着金光，然后闪着银光，天空从浅红变做天蓝。海面上看不见一条船。在这小岛顶上有一座玩具一样的龙王庙。也许人们不会来救我，我还要回到海里，试着自己游回岸上去但是我并不害怕。我不觉得饿，还可以支持很久。我既可以等待，也可以游泳。现在我愿意等待。于是我叉手于胸站在小岛顶上。我感到自豪，因为我取得了第一个胜利，我毫不怀疑胜利是会接踵而至的。我能够战胜命运，把自己随心所欲地改变，所以我是英雄。我做到了第一件做不到的事情，我也可以接着做下去。我喜欢我的诗，因为我知道它是真正美好的，它身上有无可争辩的光辉。我也喜欢我自己造出的我自己，我对他满意了。 有一只小船在天边出现，一个白色的小点，然后又象一只白天鹅。我站在山顶上，把衬衫脱下来挥舞。是她，独自划着一条白色的救生艇，是从海军炮校的游泳场搞来的。她在船上挥着手。我跑到岸边去接她。 她哭着拥抱我，说在海上找了我一夜。人们都相信我已经淹死了，但是她不相信我会死。我把她引到那块石头前，让她看我写的诗。她默默地看了很久，然后向我要那片硬质合金，要我把我的名字刻上去。可是我不让她刻。我不需要刻上我的名字。名字对我无关紧要。我不希望人们知道我的名字，因为我的胜利是属于我的。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>王小波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TS初始化语法]]></title>
    <url>%2F2018%2F07%2F04%2FTS%E8%AF%AD%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[TS语法初始化一个项目 1.初始化项目：进入你的编程文件夹后，可以使用npm init -y来初始化项目，生成package.json文件。 2.创建tsconfig.json文件，在终端中输入tsc –init：它是一个TypeScript项目的配置文件，可以通过读取它来设置TypeScript编译器的编译参数。 3.安装@types/node,使用npm install @types/node –dev-save进行安装。这个主要是解决模块的声明文件问题。 4.编写HelloWorld.ts文件，然后进行保存，代码如下。12var a:string = "HelloWorld"console.log(a) 5.在Vscode的任务菜单下，打开Terminal下的Run Build Task，然后选择tsc：build-tsconfig.json，这时候就会生成一个helloWorld.js文件123"use strict";var a = 'helloworld';console.log(a); 6.在终端中输入node helloWorld.js就可以看到结果了。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F04%2F06%2Fwebpack%2F</url>
    <content type="text"><![CDATA[网页中有哪些静态资源 JS .js .jsx .coffee .ts CSS .css .less .scss Images .jpg .png .gif .bmp .svg 字体文件 .svg .ttf .eot .woff .woff2 模板文件 .ejs .vue(这是在webpack中定义组件的方式) 网页中引入静态资源过多，会有什么问题 网页加载速度慢，因为我们要发起很多的二次请求 要处理错综复杂的依赖关系处理静态资源加载的问题 合并、压缩js.css文件 处理图片请求的时候，可以将图片设置成base64编码，这样会随着html结构一起加载 处理依赖关系，使用Gulp webpack什么是webpackwebpack 是前端的一个项目构建工具，它是基于node.js开发出来的一个前端工具]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-components]]></title>
    <url>%2F2018%2F04%2F02%2FVue-components%2F</url>
    <content type="text"><![CDATA[组件 - components 定义: 组件的出现，就是为了拆分vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可; 组件化和模块化的区别 模块化:是从代码逻辑的角度进行划分的,方便代码分层开发,保证每个功能模块的只能单一。 组件化:是从UI界面的角度进行划分的，前端的组件化，方便UI组件的重用。 创建组件的方式第一种 1.1 123let com1 = Vue.extend(&#123; template:"&lt;h3&gt;这是使用Vue.extend创建出来的组件&lt;/h3&gt;"&#125;) 1.2Vue.component(“mycom1”,com1) 引入的时候,使用标签进行渲染可以合并成一步: 123Vue.component('mycom1',Vue.extend(&#123; template:"&lt;h3&gt;这是使用Vue.extend创建出来的组件&lt;/h3&gt;"&#125;)) 第二种12345注意:无论是哪种方式创建出来的组件，组件的template属性指向的内容， 必须有且只有唯一的一个根元素 Vue.component('mycom2',&#123; template:'&lt;div&gt;&lt;h3&gt;这是使用Vue.extend创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;' &#125;) 第三种Vue.component(&#39;mycom2&#39;,{template:&#39;#temp1&#39;}) 在APP控制的区域外，定义一个ID为temp1的template标签，在标签元素节点可以写你想要的代码 组件中的data123456789101112131415161718192021注意：data必须是一个函数，而且函数必须返回一个对象， 模板中的元素行内指令可以调用，这里返回对象的意义， 当调用多次同一个组件的时候，虽然返回对象内容相同， 但是是引用数据类型，空间地址不一样， 组件之间的数据完全独立，不会因为其他组件数据的变化而变化let vm2 = new Vue(&#123; el:'#app2', data:&#123; &#125;, components:&#123; login:&#123; template:'#temp1', data:function()&#123; return&#123; msg:'' &#125; &#125; &#125; &#125; &#125;) Vue提供的4个标签属性 transitiontransition-grouptemplatecomponent 子父组件 如何相互传值1&lt;son :parentmsg = "msg" @parentfuc123 = "fn"&gt;&lt;/son&gt; 父传子父组件通过绑定自定义属性，向子组件内传入数据子组件通过props:[‘自定义属性名’]，接收父组件传进的数据 具体实现方式 =&gt; :parentmsg = &quot;msg&quot; (parentmsg为自定义属性名，msg为父组件内的数据)使用过程中注意:1.传入的数据可以是基本数据类型，也可以是引用数据类型;2.可以是父组件中的data数据，也可以是methods中的方法(但是我们需记住:VUE不希望我们以自定义属性的方式，传入methods中的方法);3.不能直接修改props中父组件传进来的数据,虽然子组件可以渲染出修改后的数据，但是只要父组件视图发生变化，就会重新覆盖子组件的内容;4.但是，当我们传入一个引用数据类型，在原地址修改数据时不会引起报错,能成功修改父组件的数据;5.子组件使用父组件的数据是一个单向的数据流;12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;son :parentname = 'val' :myname ="name" :arr = ary v-for = "val in ary" :key = "val"&gt; &lt;/son&gt;&lt;/div&gt;&lt;template id="son"&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;parentname&#125;&#125;&lt;/h2&gt; &lt;h3 v-for = "i in arr"&gt;&lt;/h3&gt; &lt;button @click="fn"&gt;这个按钮点击&#123;&#123;n&#125;&#125;次&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;let son =&#123; template:'#son', props:['parentname','myname','arr'], data()&#123;return&#123;n:0&#125;&#125;, methods:&#123; fn()&#123; this.n++ this.arr.push('node') &#125; &#125;let vm = new Vue(&#123; el:'#app', data:&#123; name:'hello', ary:['css','js','vue'] &#125;, components:&#123; son &#125; 子传父父组件通过绑定自定义事件，向子组件内传入methods方法子组件通过调用this.$emit(‘自定义事件名’，第一参数,第二参数…)方法，接收父组件方法，并通过第一参数，第二参数…，同时向父组件内传值 具体实现方式 =&gt; @parentfuc123 = &quot;fn&quot; (parentfuc123为自定义属性名，fn为父组件内的methods方法)123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;son @qqq = "change"&gt;&lt;/son&gt;&lt;/div&gt;&lt;template id="son"&gt; &lt;div&gt; &lt;input type="text" v-model="n"&gt; &lt;button @click = "fn"&gt;通过自定义事件改变父组件的name&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;let son = &#123; template:'#son', data()&#123;return&#123;n:''&#125;&#125;, props:['aaa'], methods:&#123; fn()&#123;this.$emit('qqq',this.n)&#125; &#125;&#125;let vm = new Vue(&#123; el:'#app', data:&#123;name:'hello'&#125;, components:&#123; son &#125;, methods:&#123; change(val)&#123; this.name = val &#125; &#125;&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router]]></title>
    <url>%2F2018%2F03%2F29%2FVue-router%2F</url>
    <content type="text"><![CDATA[路由 v-router前端路由和后端路由的区别 后端路由:对于普通网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源 前端路由:对于单页面应用程序(SPA)来说，主要是通过URL中的hash值来实现不同页面之间的切换；同时，hash有一个特点:HTTP请求中不包括hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现 在单页面应用程序中，这种通过hash改变切换页面的方式，称作前端路由（区别于后端路由） 创建一个路由对象及语法规则（不适用于webpack）123456789101112131415161718192021&lt;script src = 'https://unpkg.com/vue-router@2.0.0/dist/vue-router.js'&gt;&lt;/script&gt; //第一步安装路由，要在vue.js之后 // 引入后，在window全局对象中，就有了一个路由的构造函数，叫做VueRouter let routerObj = new VueRouter(&#123; routes:[ // =&gt; 路由匹配的规则 &#123;path:'/login',component:login&#125;, &#123;path:'/',redirect:'/login'&#125; //=&gt; 重定向，强制页面默认在login页面上 // =&gt; 1.每个路由规则都是一个对象，这个队则身上必须有两个属性 // =&gt; 2.属性1: 是path，表示监听这个路由地址 // =&gt; 3.属性2: 是component，表示前面匹配是path， 则展示对应的component对应的组件 // =&gt; 注意: component的属性值必须是一个模板对象,不能是组件名称 ] &#125;) 通过：router:routerObj 将路由对象挂载到实例上 通过：router-view 将符合path的组件展示在页面上，若出现多个view，则会重复展示符合条件的组件 通过：&lt;router-link to = "/login"&gt;登录&lt;/router-link&gt; &lt;router-link to = "/resister"&gt;注册&lt;/router-link&gt; router-link 相当于a标签，点击，跳转到指定的hash值 路由传参的两种方式 ‘?’ 传参，通过this.$route.query.id 获取 1234 &lt;router-link to = &quot;/login?id=10&amp;name=zs&quot;&gt;登录&lt;/router-link&gt;&#123;path:&apos;/login&apos;,component:login&#125;console.log(this.$route.query.id)通过路径?传参方式传入的值，通过query获取 在模板中通过:id /: name 先进行占位，然后在vm的实例中进行设置，最后可通过params获取 123&lt;router-link to = &quot;/register/id=20/name=wl&quot;&gt;注册&lt;/router-link&gt;&#123;path:&apos;/register/:id/:name&apos;,component:register&#125;console.log(this.$route.params.id) 注意原理: 1)当我们通过传参时，vue都会通过设置的path，解析出一个正则regexp,去匹配fullpath 2)当fullpath是?传参时，匹配失败，params为空，但是可以通过query获取 3)当我们通过设置path占位符时，捕捉到fullpath，可以通过params获取 路由的嵌套 使用children属性，实现子路由，同时，子路由的path前面，不要带’/‘,否则以根路径开始请求，这样不方便客户理解URL路径123456789101112let router = new VueRouter(&#123; routes: [ &#123; path:'/account', component:account, children:[ &#123;path:'login',component:login&#125;, &#123;path:'register',component:register&#125; ] &#125; ] &#125;) 命名视图的用法1&lt;router-view name = "left"&gt;&lt;/router-view &gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-transition]]></title>
    <url>%2F2018%2F03%2F29%2FVue-transition%2F</url>
    <content type="text"><![CDATA[Vue动画在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js列表动画效果 transition这个过渡， 内里只能有一个根元素，且只对根元素起作用 duration: 控制Vue设置的类名存在的时间，但是动画效果还是C3设定的时间完成，duration只是延长类名存在时间 li{ background-color: hotpink; transition: all 1s ease; }定义动画开始和结束前的状态.v-enter,.v-leave-to{ transform: translateY(30px); }定义动画开始和结束过程中的状态.v-enter-active,.v-leave-active{ transition: all 0.7s ease; }1.定义元素位置除了display：none外，移动的效果2.move和leave-active 必须结合起来使用3.在结构元素节点上定义 appear 属性 使初始视图具有出场的效果.v-move{ transition: all 0.7s ease; }.v-leave-active{ position: absolute; }]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>transition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生命周期]]></title>
    <url>%2F2018%2F03%2F27%2FVue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Vue实例的生命周期 什么是生命周期:从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子:就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类: 创建期间的生命周期函数: beforeCreate : 实例刚在内存中被创建出来，此时，还没有初始化好data和methods属性 created : 实例在内存中创建OK，此时data和methods已经创建OK，此时还没有开始编译模板 beforeMount : 此时已经完成了模板的编译，但是还没有挂载到页面中 mounted : 此时，已经将编译好的模板，挂载到页面指定的容器中显示 运行期间的生命周期函数: beforeUpdate : 状态更新之前执行函数。此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated : 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了 销毁期间的生命周期函数: beforeDestroy : 实例销毁之前调用，在这一步，实例仍然完全可用。 destroyed : Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会被解除绑定，所有的事件监听器都会被移除，所有的子实例也会被销毁]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-mvvm解析]]></title>
    <url>%2F2018%2F03%2F26%2FVue-mvvm%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Vue.js 的细节 Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节： Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。 Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。 Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。 Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue指令及基础知识]]></title>
    <url>%2F2018%2F03%2F26%2FVue-%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[VUE 数据驱动:操作DOM JS的数据类型 基本 和 引用 改变原数组 —&gt; 数组的变异 pop push shif unshift reverse sort splice(n,m,x,y,z) 不改变原数组 —&gt; slice(n,m) concat indexOf join(‘+’) toString() 数组的迭代方法 forEach map:renturn什么值，就往新数组添加新属性，若没有return值，就添加undefined filter 1)filter的回调函数中return值，若是true，则把当前迭代的项复制一份到新数组arr中 2)filter的返回值是新数组arr some: 1)回调函数中只要有一个回调函数返回的是true，则整个some 返回值就是ture 2)只要某个项满足条件，就不在进行迭代 every: 1)回调函数，每一个都是true，every的返回值才是true 2)换句话说就是只要有一个是false ，整个结果就是false reduce((prev,next)=&gt;):结果就是最后一次迭代的return值 find: 找到满足条件的第一项 includes(item,index)从index索引值开始查找 找到就是true 找不到就是false NODE基础命令 package.json 是项目的依赖表单 dependencies:存储的都是生产环境的依赖 devdependencies:储存的都是开发环境的依赖 scripts:中存储的都是要执行的命令对应的代码 npm run hello : 对应的要执行hello对应的代码 npm i vue –save:在项目中添加依赖，安装依赖 npm i yarn -g : 全局安装yarn，以后可以使用yarn代替npm 去安装一些依赖 VUE - M-V-VM 1.vue 双向数据绑定 ；渐进式；框架 2.视图 V 数据 M VM 3.视图改变 数据自动更新 4.数据更新 视图自动更改 5.渐进式: SPA 单页面开发 核心:vue.js vue-router控制路由 vuex 处理数据 axios 解决请求 声明式 编程式 forEach 声明式 for() 编程式 框架 框架:自己写的代码被框架调用 Vue React Angular BootStrap 库: 自己调用库的代码 Vue的指令 1.v-model: 是vue的指令 name是实例的变量 指令是指让对应的元素做某件事 2.v-text : 展示对应的文本 3.v-once : 对应的标签只渲染一次 1~3指令都是行内属性 4.v-html : 把值中的标签渲染出来 5.v-cloak : 解决渲染闪烁问题[v-cloak] {display: none;} &lt;div v-cloak&gt;{{ message }}&lt;/div&gt; 6.v-show : 控制元素的display:ngone 属性 7.v-on:click : 给元素绑定事件 简写 @click = &#39;fn&#39; 8.v-keyup.enter = ‘fn’ : 给元素绑定键盘事件 9.v-bind:绑定样式 对象 路径 缩写: : 10.v-for : 循环显示元素的,可以循环数组，也可以循环对象、字符串、数字 ，v-for优先级比v-if/else的优先级高，先渲染v-for 11.v-if / v-else-if /v-else :直接不加载元素,先做循环再做判断v-model指令 实现 数据和视图 双向绑定 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt;等表单元素和components组件 单个复选框，绑定到布尔值： 1&lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; CheckBox 多个复选框,绑定到同一个数组：check = [] CSS HTML JS check 若为 [] 一个数组 则3个input框能联系在一起,选择input框，则会在数组中push表单框中的value值 12345radio 单选框 &lt;!-- 多个input绑定同一个变量即可 --&gt; &lt;input type="radio" v-model="fruit" value="1"/&gt;🍎 &lt;input type="radio" v-model="fruit" value="2"/&gt;🍌 &lt;input type="radio" v-model="fruit" value="3"/&gt;🍊 v-model实现数据双向绑定的原理get方法 获取数据，当属性依赖于其他data中属性时，其他数据改变，才会触发这个方法，但必不会触发set方法 最终值是由get方法决定的123456789var obj = &#123;&#125;;Object.defineProperty(obj,'name',&#123; get()&#123;return 123&#125;, set(val)&#123; console.log(val) &#125;&#125;)obj.name = 333;console.log(obj.name) set方法 使用v-model:进行数据的双向绑定 只有点击改变值的时候，才会触发这个方法，触发这个方法必然触发了get方法 修饰符事件修饰符 self: 只有点击元素本身的时候才触发 stop:阻止冒泡 prevent:阻止默认事件 once: 对应的函数只触发一次 capture: 让事件在捕获阶段触发 passive : 优先执行默认事件，在执行绑定的函数，优化移动端性能，只对滚动行为有效v-model修饰符 number : 将字符串转化为数字 类似 parsefloat的效果 trim : 自动去除首尾空格 自定义全局键码Vue.config.keyCodes.f2 = 113 =&gt; 在模板中可以这样使用 `@keyup.f2 = fn’’`· 过滤器1&#123;&#123;money | changeM&#125;&#125; 管道符前边是要处理的数据，后边是处理的参数，最终展示的是函数的返回值 过滤器是可以连续使用的，下一个过滤器的返回值，是上一个过滤器的返回值 全局过滤器和私有过滤器，全局过滤器任何组件都可以调用，私有过滤器只有定义过滤器的组件可以调用 filter 中的方法 可以重名，不会被冲掉，但尽可能不要重名123456Vue.filter('过滤器名称'，function()&#123;&#125;) 全局过滤器 console.log(this) //=&gt; this 指向window在vm实例中定义filters:&#123; '过滤器名称':functon()&#123;&#125;&#125; 私有过滤器 侦听器 Watch 异步用监听,但是比较耗性能，能够深层监听，能够返回oldV 和 newV 两个值供实例调用 深层监听的属性必须是有set和get方法的属性值 当监听一个数组的时候，若数组地址不发生改变，那么不会触发watch的方法 Watch还可以监听到路由的变化 具有局限性，当监听的数据过多时，不适合使用watch方法 计算属性 Computed 同步用计算属性，但依赖性太强，用到get/set方法 定义的方法，挂载在vm的实例，不能跟methods和data重名，但是现在不报错，但是不能用，因为methods中的方法会把computed中的方法冲掉 只要name不发生改变，name2就不发生改变 name2用到谁，就依赖谁 conputed计算属性，具有缓存机制，若数据发生改变，会重新计算属性，若只是重复调用，则不会触发computed方法 123456789101112131415computed:&#123; name2()&#123; return this.name.split('').rerverse().join('') &#125;, name3()&#123; get()&#123; console.log(this.name) return 123 &#125;, set(val)&#123; // 给name3赋值的时候会触发, set函数 // val 是外界 &#125; &#125;&#125; computed / watch / methods 三者的区别 computed : 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算，主要当做属性来使用 watch : 一个对象，键是需要观察的表达式，值是对应的回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是methods和computed的结合体 methods : 表示一个具体的操作，主要书写业务逻辑自定义全局指令 使用directive定义全局的指令 其中参数1：指令的名称，注意，在定义的时候，指令的名称前面，不需要加 -v 前缀 但是在调用的时候，必须在指令名称前加上 v- 前缀 进行调用 参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 12345678910111213 bind:function(el)&#123; =&gt;每当指令绑定到元素身上的时候，会立即执行这个bind函数，只执行一次 //1.注意：在每个函数中，第一个参数永远是el，表示被绑定的那个元素，这个el参数以一个原生JS对象 //2.在元素刚绑定指令的时候，还没有插入到DOM中，这时候，调用focus方法没有起作用 //3.因为，一个元素只有插入到DOM中，才能获取焦点 //el.focus() &#125;, inserted:function(el)&#123; =&gt;表示元素被插入到DOM中的时候，触发这个inserted函数，触发一次 el.focus() &#125;, updated:function(el)&#123; =&gt;每当VNode更新的时候，会执行updated函数，可能会被触发多次 &#125; &#125;) 自定义指令简写:Vue.directive(&#39;focus&#39;,function(el,binding){}) 钩子函数 钩子函数的参数: 指令钩子函数会被传入以下实参 1.el : 指令所绑定的元素，可以用来直接操作 DOM 2.binding: name: 指令名，不包括 v- 前缀; value:指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2; expression:字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 &quot;1 + 1&quot;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的继承方式]]></title>
    <url>%2F2017%2F05%2F12%2FJS%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[类的继承和多态 封装: 把实现一个功能的代码放在一个函数中封装起来，以后再想实现这个功能的时候，我们不需要重新的编写代码了，只需要执行对应的函数即可，我们把这种机制就称之为”函数的封装”–&gt;低耦合高内聚:减少页面中的冗余代码,提高代码的重复使用率12345function fn()&#123; 实现功能的代码&#125; fn(); fn(); 多态:后台语言[java、C#、ASP.net、php…]中的多态：重载、重写重载(Reload)：多个方法,方法名相同,参数的个数或者参数的类型不一样重写(Rewrite)：子类重写父类的方法1)JS中如果函数名相同了,后面的会把前面的函数给覆盖掉,所以JS中不存在重载 fn(); -&gt;2 functionfn(){console.log(1);}2)JS中的多态指的是一个方法的多种形态:一个方法,我们通过传递进来的参数值的不一样,实现不一样的功能根据传递的n和m的值不一样,我们获取的结果也不一样,例如:如果执行的时候不传递任何的参数,返回[0-1)之间的随机小数,如果传递了两个值1/10,返回的是[1-10]之间的随机整数12345678910111213function getRandom(n,m)&#123; n=Number(n); m=Number(m); if(isNaN(n) || isNaN(m))&#123; returnMath.random(); &#125; if(n&gt;m)&#123; n=m+n; m=n-m; n=n-m; &#125; return Math.round(Math.random()*(m-n)+n); &#125; 继承:JS中常用的继承有以下几种方式(子类想要继承父类中的属性和方法)1)原型链继承(我们项目中最常用的一种继承方式)A、子类的原型指向父类的一个实例即可-&gt;原理不是把父类中的方法直接的继承复制过来一份,而是通过原型链的查找机制一级级的向上查找使用的B、原型继承是把父类中私有和公有的属性和方法都当做子类中公有的C、子类可以通过原型链的查找机制把父类原型上的属性和方法进行添加、修改、删除,如果这样操作完成后,我们父类的其他实例都会受到影响-&gt;子类重父类的方法-&gt;类的重写,例如:c.proto.proto.getX=function(){} 相当于子类重写了父类原型上的公有的方法12345function Parent()&#123;this.x = 100;&#125;Parent.prototype.getX =function () &#123;console.log(this.x);&#125;;function Children()&#123;this.x = 200;&#125;Children.prototype = newParent;var c = newChildren; ####2)call继承（借用构造函数继承）A、在子类的函数体中,把父类当做一个普通的函数执行,让父类执行的时候里面的this变为子类的一个实例,这样就相当于直接的给子类的实例增加私有的属性和方法B、call继承只能继承父类私有的属性和方法,而且继承过来后也是子类实例自己私有的C、call继承是直接的把父类中的私有属性和方法相当于克隆一份直接的给子类123456789function Parent()&#123;this.x = 100;this.writeX = function () &#123;&#125;&#125;Parent.prototype.getX =function () &#123;console.log(this.x);&#125;;function Children()&#123; //this-&gt;Children的实例c Parent.call(this);//把Parent当做普通的函数执行,让里面的this变为c-&gt;在执行的时候相当于c.x=100、 c.writeX=function...&#125;var c = newChildren;var d = newChildren;console.log(c.writeX ===d.writeX);//--&gt;false 3)冒充对象继承A、在子类的函数体中,我们创建一个父类的实例,然后把这个实例当做一个普通的对象进行遍历,在每一次遍历的时候,把父类中私有/公有的属性和方法,都当做子类实例的私有属性和方法进行存储(使用 for in 循环可以遍历出类私有属性和自定义的属性方法)B、父类的私有和公有都可以继承,而是是相当于复制了一份继承过来的C、继承过来的都是子类实例私有的属性和方法12345678910111213function Parent()&#123;this.x = 100;this.writeX = function () &#123;&#125;&#125;Parent.prototype.getX =function () &#123;console.log(this.x);&#125;;function Children()&#123; var temp=new Parent(); //temp就是Parent的一个实例:x、writeX、getX for(var key in temp)&#123; this[key]=temp[key]; &#125; temp=null;&#125;var c = newChildren;var d = newChildren;console.log(c.getX ===d.getX); 4)组合式继承（call继承和原型链继承） 原型继承和call继承/冒充对象继承,任意一个组合到一起来实现的,一般来说都是和call继承组合 缺点： 组合式继承 1.子类会把父类的实例属性（私有属性），继承过来两份 一份存储在子类实例对象本身，另一份存储在原型链上 b insaceof A =&gt;TRUE 只要能在原型链上查找到，那么返回的就是ture 调用了两次父类，产生两个作用域，消耗浏览器内存123456789101112function Parent() &#123; this.x = 100; this.writeX = function () &#123;&#125;&#125;Parent.prototype.getX =function () &#123; console.log(this.x);&#125;;function Children()&#123; Parent.call(this);&#125;Children.prototype = newParent;var c = newChildren; 5)原型式继承 只能继承父类的公有方法,通过Object.create()方法 create : 首先创建一个新对象，并且把第一个参数 作为 这个新对象的原型 IE低版本浏览器不支持这种ES5方法1234function A ()&#123;&#125;B.prototype = Object.create(A.prototype)//=&gt; B.prototype.__proto__ === A.prototypeB.prototype = Object.create(null) //=&gt; &#123;&#125;function B ()&#123;&#125; 6)寄生组合式继承(最理想的继承方法)123456789function A ()&#123; this.title = 'xxx' &#125; B.prototype = Object.create(A.prototype)//=&gt;原型式继承 只负责继承父类的公有属性 function B ()&#123; if(this instanceof B)&#123; A.call(this)//=&gt;call继承 只负责继承父类的私有属性 &#125; &#125; 7)ES6中的继承 1.ES6中创建类是由自己标准语法的，这种语法创建出来的类，只能new执行，不能当做普通函数执行 1234567891011class Fn &#123; //=&gt;Fn是类名，没有小括号 constructor (n,m) &#123; //=&gt;等价于传统ES5类的构造体 this.x = n this.y = m &#125; getX () &#123;...&#125;//=&gt;给Fn的原型上设置方法（只能设置方法，不能设置属性） static AA（）｛...｝//=&gt;把Fn当做一个普通对象，添加私有属性（和实例没有关系，同样也只能设置方法）&#125;let f = new Fn (10,20)console.log(f.x,f.y)//=&gt; (10,20) 2.ES6中类的继承 这种方法保留了子类B的constructor属性 123456789101112131415class A &#123; constructor(n)&#123; console.log(n)//=&gt;100 this.x = 100 &#125;console.log(n)//=&gt;100console.log(n)// getX()&#123;console.log(this.x)&#125;&#125;class B extends A&#123;//=&gt;extends类似于实现了原型继承 constructor()&#123; super(100)//=&gt;类似于call继承，在这里super相当于把A的constructor给执行了，并且让方法中的this是B的实例 this.y = 200 &#125; getY()&#123;console.log(this.y)&#125;&#125;let f = new B()]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的事件]]></title>
    <url>%2F2017%2F05%2F12%2FJS%E4%BA%8B%E4%BB%B6%20%E2%80%93DOM0%20%E2%80%93DOM2%E2%80%93%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E2%80%93%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"><![CDATA[事件 –DOM0 –DOM2–发布订阅–拖拽 什么是事件? 指的是是一件事或一个行为 事件 鼠标事件 click 单击 dblclick双击 大约300ms内连续点击两次 mouseover 鼠标滑进 冒泡阶段 先自己触发 后父辈触发 mouseout 鼠标滑出 mouseenter 鼠标移入 捕获阶段 先父辈触发 后自己 mouseleave鼠标移出 mousemove 鼠标滑动（过程） mousedown 鼠标按下（不动） mouseup鼠标抬起 mousewheel鼠标滚轮移动 键盘事件 应用元素：textarea input window html body等都可绑定键盘事件 keydown (键盘按下时触发) keyup（键盘抬起来时触发） keypress（按下时并抬起来时触发，系统键是监听不到的） 系统事件 onload 加载页面资源后 onresize（浏览器窗口发生改变时触发） onscroll（滚动条发生改变时触发） DOMContentLoaded (dom元素加载完了后再触发) 表单元素 onfoucs 获取焦点（光标）时触发 onchange（表单元素发生改变,并且失去焦点后时，才能触发） oninput（移动端，表单输入时触发，只要内容发生改变就会触发） onblur（失去焦点，表示光标离开表单元素时触发） onpropertychange 只要内容发生改变，就会触发 移动端事件 ontouchstart触碰到元素触发 ontouchend离开元素触发 ontouchmove必须在点击的情况，来回移动，才能触发函数 onclick 有大约300ms的延迟 事件绑定：事件行为发生时去做的具体的事情 行为和具体事情要绑定起来这就是事件绑定呀事件对象12345678box.onclick = function(e)&#123;e:事件对象 当执行事件绑定的方法时，浏览器会将事件对象作为实参传递到方法中e.target:事件源 元素对象e.clientX:鼠标点击的位置距离 可视窗口的 左偏移e.clientY:鼠标点击的位置距离 可视窗口的 上偏移e.pageX:鼠标点击的位置距离 BODY的 左偏移e.pageY:鼠标点击的位置距离 BODY的 上偏移&#125; 兼容IE低版本浏览器的写法12345box.onclick = function ()&#123; e = e || window.event var tar = e.target || e.srcElement e.preventDefault ? e.preventDefault():e.returnValue = false 阻止默认行为&#125; 操作这个box上下左右移动 键盘事件1234567891011121314151617enter回车键 ： 13window.onkeydown = function (e)&#123; switch(e.keyCode)&#123;//键盘码 case 37 : box.style.left = parseFloat(box.style.left) - 10 + 'px' break case 38 : box.style.top = parseFloat(box.style.top) - 15 + 'px' break case 39 : box.style.left = parseFloat(box.style.left) + 25 + 'px' break case 40 : box.style.top = parseFloat(box.style.top) + 15 + 'px' break &#125; &#125; 给一个元素（如：div，ul，li）绑定一个行为（如：onclick、onmouseover）等于一个方法 方法里写要执行的东东 默认事件 先执行绑定的事件，再执行默认事件 注：天生自带默认事件的 keydown和input和keyupinput事件是在down之后，up之前触发，阻止默认后，不在触发input； a标签默认进行跳转 锚点定位功能 img绑定鼠标事件后，会触发原生鼠标拖拽事件 移动端默认事件:touchmove 阻止默认事件：document.addEventListener(‘touchmove’,function(){},{passive:false}) （在PC端时需注意，用此方式让绑定的touchmove默认事件 - 即滚动事件 先执行） 12345678910111213141516&lt;div&gt; &lt;img id = 'img' src = 'www.baidu.com'/&gt;&lt;/div&gt;img.onmousemove = function(e)&#123; e.preventDefault() &#125;&lt;a href="https://baidu.com" id="oa"&gt;百度一下&lt;/a&gt; &lt;!-- 正常跳转 --&gt;&lt;a href="javascript:;" id=""&gt;百度两下&lt;/a&gt; &lt;!-- 禁止页面跳转 --&gt;&lt;a href="" id=""&gt;百度三下&lt;/a&gt; &lt;!-- 刷新页面 --&gt;&lt;a href="Javascript :void(0);" id=""&gt;百度四下&lt;/a&gt; &lt;!-- 禁止页面跳转 --&gt;oa.onclick = function (e)&#123;e.preventDefault();alert(111)&#125; 阻止a标签这种默认行为 事件传播 事件冒泡 0级事件是在冒泡阶段触发的 阻止冒泡：e.stopPropagation||e.cancelBubble = true 事件绑定 绑定分为DOM0级事件绑定 和 DOM2级事件绑定 是按照绑定的顺序执行方法 低版本IE浏览器会乱序 DOM0级事件绑定 传统的事件绑定odiv.onclick=function问题 ： DOM0级事件绑定 对同一元素，同一事件绑定多个行为时，后面的行为会覆盖前面的行为，最终只执行最后一次绑定的行为 DOM2级事件绑定 较于0级事件绑定，优点是可以绑定多个方法第一个参数 事件类型第二个参数 事件绑定行为第三个参数 事件传播的方式oiv.addEventListener(“click”,function ( ) {alert(1)},false);true捕获阶段触发 false在冒泡阶段触发 DOM0 和 DOM2 在事件绑定上的区别 1.机制不一样 dom0采用的是给私有属性赋值，所以只能绑定一个方法 dom2采用的是事件池机制，所以能绑定多个不同的方法 2.移除的操作 box.onclick = null dom0移除 dom2 在移除的时候，必须清楚要移除哪一个方法，才能在事件池中移除，所以基于DOM2做事件绑定，我们呢要有“瞻前顾后”的思路，也就是绑定的时候考虑一下如何移除（技巧：不要绑定匿名函数，都绑定实名函数） 3.DOM2事件绑定增加了一些DOM0无法操作的事件行为，例如：DOMContentLoaded事件，（当页面中的HTML结构加载完后才能就会触发执行） IE低版本单独拿出来 IE低版本浏览器绑定方式 IE 6 ~ 8 DOM2级事件绑定odiv.attachEvent(“onclick”,function () {alert(666)})IE 低版本浏览器移除绑定odiv.detachEvent(“onclick”,function () {alert(666)}) DOM事件绑定移除 DOM0级事件移除：odiv.onclick=null DOM2级事件移除 odiv.removeEventListener(“click”,function () {alert(1)},false);移除123/*var odiv=document.getElementById('div1')odiv.onclick=function (e) &#123;&#125;*/ 事件对象 (e)浏览器天生存在的 浏览器记录了事件相关的信息 clientX 到窗口左边的距离 clientY 到窗口上边的距离 pageX 到文档左边的距离 pageY 到文档上边的距离 pageY相当于clientY+(document.documentElement.scrollTop||document.body.scrollTop) type 事件类型 target 事件源 也就是事件绑定的元素 preventDefault 阻止默认行为 IE低版本浏览器 retuenValue=true stopPropagation 阻止冒泡 IE低版本浏览器 cancelBubble=true IE6~8用Window.event 接收事件对象 e = e || Window.event 事件委托 一个容器中，有很多后代元素的点击行为都要处理一些事情，之前的思路是把需要操作的元素一一获取，然后再一一做事件绑定，在不同的方法中完成不同的需求，现在不用了，基于事件的冒泡传播机制，我们可以只给容器的Click绑定一个方法，这样不管以后点击的容器中的哪一个后代元素，都会通过事件的冒泡传播机制，把容器的Click行为触发，把绑定的方法执行，我们在方法执行的时候，根据事件对象中的事件源（e.target）来做不同的业务处理即可，这种机制既是事件委托机制1）容器中很多后代元素的某个行为要进行操作，委托给容器处理是不错的选择2）元素是动态绑定的3）需求是除了xxx，剩下的操作都是干同样的事情业务(此时把点击行为的操作委托给BODY，事件源是xxx做什么，不是同一做什么)……….. 原生拖拽拖放的流程：选中 == &gt; 拖动 == &gt; 释放 选中过程: 在HTML5标准中，为了使元素可拖动，把draggable属性设置为true。文本、图片和链接是默认可以拖放的，它们的draggable属性自动被设置成了true。图片和链接按住鼠标左键选中，就可以拖放。文本只有在被选中的情况下才能拖放。如果显示设置文本的draggable属性为true，按住鼠标左键也可以直接拖放。draggable属性：设置元素是否可拖动。 语法：1234&lt;element draggable="true | false | auto" &gt;true: 可以拖动false: 禁止拖动auto: 跟随浏览器定义是否可以拖动 拖动过程: 每一个可拖动的元素，在拖动过程中，都会经历三个过程，拖动开始 ==&gt;拖动过程中 ==&gt; 拖动结束 dragenter和dragover事件的默认行为是拒绝接受任何被拖放的元素。因此，我们必须阻止浏览器这种默认行为。e.preventDefault() 针对对象 事件名称 说明 被拖动的元素 dragstart 在元素开始被拖动时候触发 drag 在元素被拖动时反复触发 dragend 在拖动操作完成是触发 目的地对象 dragenter 当被拖动元素进入目的地元素所占据的屏幕空间时触发 dragover 当被拖动元素在目的地元素内时触发 dragleave 当被拖动元素没有放下就离开目的地元素时触发 释放过程: 到达目的地之后，释放元素事件 针对对象 事件名称 说明 目的地对象 drop 当被拖动元素在目的地元素里放下是触发，一般需要取消浏览器的默认行为 发布订阅模式（观察者模式） 思想：准备一个容器，把达到指定时间点要处理的事情，事先一一的增加到容器中（发布计划，并且向计划表中订阅方法），当到达指定时间点，通知容器中的方法依次执行即可12345678let $plan = $.Callbacks()// 创建一个空的计划表 空容器 =&gt; $plansetTimeout(function ()&#123; $plan.fire(10,20)//=&gt;fire 就是通知容器中的方法按照顺序依次执行的: 10和20是执行容器中每一个方法的时候，都会给他们出阿迪两个参数值&#125;，1000)$plan.add((x,y)=&gt;&#123;...&#125;)//=&gt;add是向容器中增加方法，remove是从容器中移除方法$plan.add((x,y)=&gt;&#123;...&#125;)$plan.add((x,y)=&gt;&#123;...&#125;) bind源码 利用形成的不销毁的栈内存，用来存值及保护变量不受全局的污染 外层套个函数用来存储我们以后需要的值，return一个匿名函数，编程思想这种编程思想我们称作柯理化函数bianc`Function.prototype.mybind = function mybind (context,…arg){ let _this = this return function anonymous(…innerArg){ _this.apply(obj,arg.concat(innerArg)) } }document.body.onclick = fn.mybind(obj,10,20)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流和防抖]]></title>
    <url>%2F2017%2F03%2F12%2FJS%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[函数节流和防抖 函数节流的原理 函数节流的原理挺简单的，估计大家都想到了，那就是定时器。当我触发一个时间时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。 代码实现12345678910function throttle(method, context) &#123; clearTimeout(methor.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;， 100); &#125; 调用：window.onresize = function()&#123; throttle(myFunc); &#125;这样两次函数调用之间至少间隔100ms impress下的节流函数封装 123456789101112var throttle = function(fn, delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125;; &#125;; 使用闭包的方法形成一个不销毁的栈内存，存放定时器变量timer 调用：window.onresize = throttle(myFunction,100) 深化函数节流 函数节流让一个函数只有在你不断触发后停下来歇会才开始执行，中间你操作得太快它直接无视你。这样做就有点太绝了。resize一般还好，但假如你写一个拖拽元素位置的程序，然后直接使用函数节流，那恭喜你，你会发现你拖动时元素是不动的，你拖完了，它直接闪到终点去。1234567891011121314151617181920var throttleV2 = function(fn, delay, mustRunDelay)&#123; var timer = null; var t_start; return function()&#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start)&#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay)&#123; fn.apply(context, args); t_start = t_curr; &#125; else &#123; timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125; &#125;; &#125;; 简单来说，函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉。1234567891011function throttle(fn, interval = 300) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 函数防抖 其实函数防抖的原理也非常地简单，通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了。123456789function debounce(fn, interval = 300) &#123; let timeout = null; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125; 总结其实函数节流与函数防抖的原理非常简单，巧妙地使用 setTimeout 来存放待执行的函数，这样可以很方便的利用 clearTimeout 在合适的时机来清除待执行的函数。 使用函数节流与函数防抖的目的，在开头的栗子中应该也能看得出来，就是为了节约计算机资源。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>函数防抖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS盒子模型]]></title>
    <url>%2F2017%2F01%2F12%2FJS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JS盒子模型 css 盒子模型 : width height border padding margin js 盒子模型 : client offset scroll client clientWidth: 盒子的文本宽度width，+ 左右padding （正常的盒子模型，当在怪异盒模型中clientWidth不能使用这个公式，我们可以理解为盒子的可视区域的宽度） clientHeight: 盒子的文本高度height，+ 上下padding clientLeft: 盒子的左border clientTop: 盒子的上border 内容溢出对client没有任何影响 offset offsetParent: 上级参照物 有定位的父级盒子 offsetWidth: 盒子文本width + 左右padding + 左右border === clientWidth + 左右border ，跟内容溢出没有关系 offsetLeft : 盒子的外边框 到 上级参照物 内边框 的距离 scroll scrollHeight 若内容没有溢出时，跟clientHeight一样 若内容溢出时，当元素增加 overflow-hidden 属性的话，那么scrollHeight的值：内容 + 上下padding；没有overflow-hidden的属性的话，内容 + 上padding-scrollTop 滚动条卷去的内容的高度-scrollLeft 滚动条卷去的内容的宽度 1）以上13个属性中，只有scrollTop和scrollLeft 可以设置的属性，其他都是只读属性2）获取一屏幕的高度： document.documentElement.clientHeight || document.body.clientHeight 对其他浏览器的兼容问题3）获取整个文档的高度：document.documentElement.scrollHeight || document.body.scrollHeight4）监听浏览器窗口发生的事件： window.onresize = function (){…}5）当遇到&lt;table&gt;&lt;/table&gt;标签时，td 和 th 父级盒子都是table，不再是body6）改变盒子的css中样式left、transform等属性改变盒子的位置，不会改变offsetLeft的值；只有改变盒子的width margin padding 值的时候，盒子的offsetLeft值才会发生改变 123456789101112131415function offset (ele)&#123; let left = ele.offsetLeft, top = ele.offsetTop, parent = ele.offsetParent while(parent &amp;&amp; parent.nodeName.toUpperCase() != 'BODY')&#123; //代码从左向右读取，先判断parent存不存在，在判断parent是否为body left += parent.clientleft + parent.offsetLeft top += parent.clientTop + parent.offsetTop parent = parent.offsetParent &#125; return &#123; left, top&#125; &#125; console.log(offset(inner)) 简单的文字循环上下移动,利用setTimeout实现123456789var timer = null, maxH = box.scrollHeight - box.clientHeight function run ()&#123; clearTimeout(timer)//清除定时器 box.scrollTop++ (box.scrollTop + 20) &gt;= maxH ? box.scrollTop = 0 : null timer = setTimeout(run,10) &#125; run() 简单的文字循环上下移动,利用setInterval实现1234var timer = setInterval(()=&gt;&#123; box.scrollTop++ (box.scrollTop + 20) &gt;= (box.scrollHeight - box.clientHeight) ? box.scrollTop = 0 : null &#125;,10) 跑马灯案例，通过改变scrollLeft值改变1234567891011121314let ul = document.querySelector('ul'), box = document.querySelector('.box') //maxL = box.scrollWidth - box.clientWidth //=&gt;理论上是800 // console.log(maxL) 但是这里输出的是0 //这是因为加载img图片是异步事件，是等页面的代码执行完成后 //再通过图片路径，，加载图片，所以输出为0 ul.innerHTML += ul.innerHTML ul.style.width = '1600px' var timer = setInterval(()=&gt;&#123; box.scrollLeft++ box.scrollLeft &gt;= 800 ? box.scrollLeft = 0 :null &#125;,10) //另外一种跑马灯思路：通过改变ul的C3的left值，使图片移动 //能够实现一样的效果，但是这样做会引发多次的DOM回流，降低浏览器性能]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>盒子模型</tag>
      </tags>
  </entry>
</search>
